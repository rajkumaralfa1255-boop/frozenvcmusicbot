import os
import re
import sys
import time
import json
import logging
import asyncio
import random
import speech_recognition as sr
from pydub import AudioSegment
from datetime import datetime, timezone, timedelta
from dotenv import load_dotenv
from flask import Flask, request
from pyrogram import Client, filters, errors
from pyrogram.enums import ChatType, ChatMemberStatus, ParseMode
from pyrogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ChatPermissions,
    ChatMember,
)
from gtts import gTTS

# Load environment variables
load_dotenv()

API_ID = int(os.environ.get("API_ID"))
API_HASH = os.environ.get("API_HASH")
BOT_TOKEN = os.environ.get("BOT_TOKEN")
OWNER_ID = int(os.getenv("OWNER_ID", "5268762773"))
LOG_CHANNEL_ID = int(os.getenv("LOG_CHANNEL_ID", None))
RSS_FEED_URL = os.environ.get("RSS_FEED_URL", "https://www.youtube.com/feeds/videos.xml?channel_id=UC-K20bY-dK_9e17W3K-252A")
RSS_CHANNEL_ID = int(os.getenv("RSS_CHANNEL_ID", None))

# Initialize the bot client
session_name = os.environ.get("SESSION_NAME", "help_bot")
bot = Client(session_name, bot_token=BOT_TOKEN, api_id=API_ID, api_hash=API_HASH)

# Define bot name for dynamic use
BOT_NAME = os.environ.get("BOT_NAME", "Frozen Help Bot")
BOT_LINK = os.environ.get("BOT_LINK", f"https://t.me/{bot.get_me().username}")

# In-memory storage for user stats, notes, and other data
user_stats = {}
last_rss_entry_link = ""
premium_users = set()
FAQ_DATA = {
    "rules": "‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§®‡§ø‡§Ø‡§Æ:\n1. ‡§ï‡•ã‡§à ‡§∏‡•ç‡§™‡•à‡§Æ‡§ø‡§Ç‡§ó ‡§®‡§π‡•Ä‡§Ç\n2. ‡§ï‡•ã‡§à ‡§ó‡§æ‡§≤‡•Ä-‡§ó‡§≤‡•å‡§ú ‡§®‡§π‡•Ä‡§Ç\n3. ‡§ï‡•á‡§µ‡§≤ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§∏‡§Ç‡§¨‡§Ç‡§ß‡§ø‡§§ ‡§¨‡§æ‡§§‡•á‡§Ç‡•§",
    "help": "‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§¶‡§¶ ‡§ï‡•à‡§∏‡•á ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Å? `/help` ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è ‡§¨‡§ü‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§",
    "contact": "‡§è‡§°‡§Æ‡§ø‡§® ‡§∏‡•á ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è @Frozensupport1 ‡§™‡§∞ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§",
}

warn_counts = {}
user_message_timestamps = {}
scheduled_messages = []
user_reputation = {}
auto_delete_timers = {}
notes_data = {}
gban_list = set()
custom_welcome_messages = {}

# Auto-mute on low messages settings
LOW_MSG_MUTE_THRESHOLD = 5
LOW_MSG_MUTE_TIME = 300 # 5 minutes

# Pre-defined quotes list
QUOTES = [
    "‡§∏‡§™‡§®‡•á ‡§µ‡•ã ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã‡§§‡•á ‡§ú‡•ã ‡§π‡§Æ ‡§∏‡•ã‡§§‡•á ‡§π‡•Å‡§è ‡§¶‡•á‡§ñ‡§§‡•á ‡§π‡•à‡§Ç, ‡§∏‡§™‡§®‡•á ‡§µ‡•ã ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç ‡§ú‡•ã ‡§π‡§Æ‡•á‡§Ç ‡§∏‡•ã‡§®‡•á ‡§®‡§π‡•Ä‡§Ç ‡§¶‡•á‡§§‡•á‡•§ - ‡§Ö‡§¨‡•ç‡§¶‡•Å‡§≤ ‡§ï‡§≤‡§æ‡§Æ",
    "‡§ú‡•ã ‡§≤‡•ã‡§ó ‡§ñ‡•Å‡§¶ ‡§∏‡•á ‡§™‡•ç‡§Ø‡§æ‡§∞ ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç, ‡§µ‡•á ‡§¶‡•Å‡§®‡§ø‡§Ø‡§æ ‡§ï‡•ã ‡§¨‡§¶‡§≤‡§®‡•á ‡§ï‡•Ä ‡§∂‡§ï‡•ç‡§§‡§ø ‡§∞‡§ñ‡§§‡•á ‡§π‡•à‡§Ç‡•§ - ‡§Æ‡§π‡§æ‡§§‡•ç‡§Æ‡§æ ‡§ó‡§æ‡§Ç‡§ß‡•Ä",
    "‡§∏‡§´‡§≤‡§§‡§æ ‡§ï‡•Ä ‡§ñ‡•Å‡§∂‡•Ä ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§≠‡§µ ‡§ï‡§∞‡§®‡•á ‡§∏‡•á ‡§™‡§π‡§≤‡•á, ‡§á‡§Ç‡§∏‡§æ‡§® ‡§ï‡•ã ‡§Ö‡§∏‡§´‡§≤‡§§‡§æ ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§≠‡§µ ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è‡•§ - ‡§°‡•â. ‡§è.‡§™‡•Ä.‡§ú‡•á. ‡§Ö‡§¨‡•ç‡§¶‡•Å‡§≤ ‡§ï‡§≤‡§æ‡§Æ",
    "‡§Ö‡§ó‡§∞ ‡§§‡•Å‡§Æ ‡§∏‡•Ç‡§∞‡§ú ‡§ï‡•Ä ‡§§‡§∞‡§π ‡§ö‡§Æ‡§ï‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•ã, ‡§§‡•ã ‡§™‡§π‡§≤‡•á ‡§∏‡•Ç‡§∞‡§ú ‡§ï‡•Ä ‡§§‡§∞‡§π ‡§ú‡§≤‡§®‡§æ ‡§∏‡•Ä‡§ñ‡•ã‡•§ - ‡§°‡•â. ‡§è.‡§™‡•Ä.‡§ú‡•á. ‡§Ö‡§¨‡•ç‡§¶‡•Å‡§≤ ‡§ï‡§≤‡§æ‡§Æ",
    "‡§ï‡§∞‡•ç‡§Æ‡§≠‡•Ç‡§Æ‡§ø ‡§™‡§∞ ‡§´‡§≤ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∂‡•ç‡§∞‡§Æ ‡§∏‡§¨‡§ï‡•ã ‡§ï‡§∞‡§®‡§æ ‡§™‡•ú‡§§‡§æ ‡§π‡•à, ‡§≠‡§ó‡§µ‡§æ‡§® ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§≤‡§ï‡•Ä‡§∞‡•á‡§Ç ‡§¶‡•á‡§§‡§æ ‡§π‡•à, ‡§∞‡§Ç‡§ó ‡§π‡§Æ‡•á‡§Ç ‡§ñ‡•Å‡§¶ ‡§≠‡§∞‡§®‡§æ ‡§™‡•ú‡§§‡§æ ‡§π‡•à‡•§ - ‡§Ö‡§ú‡•ç‡§û‡§æ‡§§",
]

# --- Helper functions ---

# Recreating the privilege validator function
async def is_admin_or_owner(message: Message):
    if message.from_user.id == OWNER_ID:
        return True
    
    chat_member: ChatMember = await message._client.get_chat_member(
        chat_id=message.chat.id,
        user_id=message.from_user.id
    )
    return chat_member.status in [
        ChatMemberStatus.ADMINISTRATOR,
        ChatMemberStatus.OWNER
    ]

def to_bold_unicode(text: str) -> str:
    bold_text = ""
    for char in text:
        if 'A' <= char <= 'Z':
            bold_text += chr(ord('ùóî') + (ord(char) - ord('A')))
        elif 'a' <= char <= 'z':
            bold_text += chr(ord('ùóÆ') + (ord('char') - ord('a')))
        else:
            bold_text += char
    return bold_text

async def extract_target_user(message: Message):
    if message.reply_to_message:
        return message.reply_to_message.from_user
    
    parts = message.text.split()
    if len(parts) < 2:
        await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡§ø‡§∏‡•Ä ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§â‡§∏‡§ï‡§æ @username/user_id ‡§¶‡•á‡§Ç‡•§")
        return None

    target = parts[1]
    if target.startswith("@"):
        target = target[1:]
    try:
        user = await message._client.get_users(target)
        return user
    except:
        await message.reply("‚ùå ‡§Ø‡§π ‡§Ø‡•Ç‡•õ‡§∞ ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§")
        return None

async def log_admin_action(action: str, admin: str, target: str):
    if LOG_CHANNEL_ID:
        log_message = f"üõ°Ô∏è **‡§è‡§°‡§Æ‡§ø‡§® ‡§≤‡•â‡§ó**\n\n**‡§ï‡§æ‡§∞‡•ç‡§Ø:** {action}\n**‡§è‡§°‡§Æ‡§ø‡§®:** {admin}\n**‡§≤‡§ï‡•ç‡§∑‡•ç‡§Ø:** {target}"
        try:
            await bot.send_message(LOG_CHANNEL_ID, log_message)
        except Exception as e:
            print(f"Failed to send log to channel: {e}")

# --- New Enhanced UI for Start/Help ---
@bot.on_message(filters.command(["start", "help"]))
async def start_and_help_handler(_, message):
    user_id = message.from_user.id
    raw_name = message.from_user.first_name or ""
    styled_name = to_bold_unicode(raw_name)

    caption = (
        f"üëã **‡§®‡§Æ‡§∏‡•ç‡§§‡•á {styled_name}!**\n\n"
        f"‡§Æ‡•à‡§Ç ‡§è‡§ï ‡§è‡§°‡§µ‡§æ‡§Ç‡§∏ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•à‡§®‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§Ö‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§π‡•Ç‡§Å‡•§\n"
        f"‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•ã ‡§∏‡§æ‡§´, ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§î‡§∞ ‡§µ‡•ç‡§Ø‡§µ‡§∏‡•ç‡§•‡§ø‡§§ ‡§∞‡§ñ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡§æ ‡§π‡•Ç‡§Å‡•§\n\n"
        f"‡§Æ‡•á‡§∞‡•á ‡§∏‡§≠‡•Ä ‡•û‡•Ä‡§ö‡§∞‡•ç‡§∏ ‡§ï‡•ã ‡§è‡§ï‡•ç‡§∏‡§™‡•ç‡§≤‡•ã‡§∞ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è **Help** ‡§¨‡§ü‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§\n\n"
        f"**Developer:** [Shubham](tg://user?id={OWNER_ID})"
    )
    buttons = [
        [
            InlineKeyboardButton("‚ûï ‡§Æ‡•Å‡§ù‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§ú‡•ã‡§°‡§º‡•á‡§Ç", url=f"https://t.me/{bot.get_me().username}?startgroup=true"),
            InlineKeyboardButton("üì¢ ‡§Ö‡§™‡§°‡•á‡§ü‡•ç‡§∏", url="https://t.me/vibeshiftbots")
        ],
        [
            InlineKeyboardButton("‚ùì Help", callback_data="show_help"),
            InlineKeyboardButton("üí¨ ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü", url="https://t.me/Frozensupport1")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(buttons)
    await message.reply_animation(
        animation="https://frozen-imageapi.lagendplayersyt.workers.dev/file/2e483e17-05cb-45e2-b166-1ea476ce9521.mp4",
        caption=caption,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )

@bot.on_callback_query(filters.regex("show_help"))
async def show_help_callback(_, callback_query):
    text = "**üìö ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏ ‡§ï‡§æ ‡§Æ‡•á‡§®‡•Ç**\n\n‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è ‡§¨‡§ü‡§®‡•ç‡§∏ ‡§∏‡•á ‡§Ü‡§™ ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏ ‡§ï‡•ã ‡§ï‡•à‡§ü‡•á‡§ó‡§∞‡•Ä ‡§ï‡•á ‡§Ö‡§®‡•Å‡§∏‡§æ‡§∞ ‡§¶‡•á‡§ñ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§"
    buttons = [
        [InlineKeyboardButton("üõ°Ô∏è ‡§è‡§°‡§Æ‡§ø‡§® ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏", callback_data="help_admin"),
         InlineKeyboardButton("üöÄ ‡§Ø‡•Ç‡§ü‡§ø‡§≤‡§ø‡§ü‡•Ä ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏", callback_data="help_utility")],
        [InlineKeyboardButton("üòÑ ‡§Æ‡§®‡•ã‡§∞‡§Ç‡§ú‡§® ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏", callback_data="help_fun"),
         InlineKeyboardButton("‚ÑπÔ∏è ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏", callback_data="help_info")],
        [InlineKeyboardButton("üè† ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§™‡•á‡§ú ‡§™‡§∞ ‡§µ‡§æ‡§™‡§∏", callback_data="go_back")]
    ]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("help_admin"))
async def help_admin_callback(_, callback_query):
    text = (
        "üõ°Ô∏è **‡§è‡§°‡§Æ‡§ø‡§® ‡§î‡§∞ ‡§Æ‡•â‡§°‡§∞‡•á‡§∏‡§® ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏**\n\n"
        "`/mute <reply> or <username>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§π‡§Æ‡•á‡§∂‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/tmute <reply> <time>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§ï‡•Å‡§õ ‡§¶‡•á‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/unmute <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§Ö‡§®‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/ban <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§¨‡•à‡§® ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/unban <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§Ö‡§®‡§¨‡•à‡§® ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/kick <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§ï‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/warn <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡•Ä ‡§¶‡•á‡§Ç (3 ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•á ‡§¨‡§æ‡§¶ ‡§¨‡•à‡§®)‡•§\n"
        "`/resetwarns <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•Ä ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§∞‡•Ä‡§∏‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/del`: ‡§Æ‡•à‡§∏‡•á‡§ú ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/setwelcome`: ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§µ‡•á‡§≤‡§ï‡§Æ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§∏‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/autodelete <time>`: ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡•ã ‡§ë‡§ü‡•ã-‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§"
    )
    buttons = [[InlineKeyboardButton("üîô ‡§µ‡§æ‡§™‡§∏", callback_data="show_help")]]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("help_utility"))
async def help_utility_callback(_, callback_query):
    text = (
        "üöÄ **‡§Ø‡•Ç‡§ü‡§ø‡§≤‡§ø‡§ü‡•Ä ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏**\n\n"
        "`/tts <text>`: ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ï‡•ã ‡§ë‡§°‡§ø‡§Ø‡•ã ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤‡•á‡§Ç‡•§\n"
        "`/vtt`: ‡§µ‡•â‡§á‡§∏ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡•ã ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤‡•á‡§Ç‡•§\n"
        "`/schedule <time> <text>`: ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡•ã ‡§∂‡•á‡§°‡•ç‡§Ø‡•Ç‡§≤ ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/broadcast <message>`: ‡§∏‡§≠‡•Ä ‡§ó‡•ç‡§∞‡•Å‡§™‡•ç‡§∏ ‡§Æ‡•á‡§Ç ‡§¨‡•ç‡§∞‡•â‡§°‡§ï‡§æ‡§∏‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç (‡§ï‡•á‡§µ‡§≤ ‡§Æ‡§æ‡§≤‡§ø‡§ï)‡•§\n"
        "`/gban <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§¨‡•â‡§ü ‡§ï‡•á ‡§∏‡§≠‡•Ä ‡§ó‡•ç‡§∞‡•Å‡§™‡•ç‡§∏ ‡§∏‡•á ‡§¨‡•à‡§® ‡§ï‡§∞‡•á‡§Ç (‡§ï‡•á‡§µ‡§≤ ‡§Æ‡§æ‡§≤‡§ø‡§ï)‡•§\n"
        "`/ungban <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§¨‡•â‡§ü ‡§ï‡•á ‡§∏‡§≠‡•Ä ‡§ó‡•ç‡§∞‡•Å‡§™‡•ç‡§∏ ‡§∏‡•á ‡§Ö‡§®‡§¨‡•à‡§® ‡§ï‡§∞‡•á‡§Ç (‡§ï‡•á‡§µ‡§≤ ‡§Æ‡§æ‡§≤‡§ø‡§ï)‡•§"
    )
    buttons = [[InlineKeyboardButton("üîô ‡§µ‡§æ‡§™‡§∏", callback_data="show_help")]]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("help_fun"))
async def help_fun_callback(_, callback_query):
    text = (
        "üòÑ **‡§Æ‡§®‡•ã‡§∞‡§Ç‡§ú‡§® ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏**\n\n"
        "`/poll <question> <options>`: ‡§è‡§ï ‡§™‡•ã‡§≤ ‡§¨‡§®‡§æ‡§è‡§Ç‡•§\n"
        "`/couple`: ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡§æ 'Couple of the Day' ‡§ö‡•Å‡§®‡•á‡§Ç‡•§\n"
        "`/dice`: ‡§è‡§ï ‡§°‡§æ‡§á‡§∏ ‡§∞‡•ã‡§≤ ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/rep <reply>`: ‡§ï‡§ø‡§∏‡•Ä ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•Ä ‡§™‡•ç‡§∞‡§§‡§ø‡§∑‡•ç‡§†‡§æ ‡§¨‡§¢‡§º‡§æ‡§è‡§Ç‡•§\n"
        "`/reps`: ‡§∏‡§¨‡§∏‡•á ‡•õ‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§™‡•ç‡§∞‡§§‡§ø‡§∑‡•ç‡§†‡§æ ‡§µ‡§æ‡§≤‡•á ‡§∏‡§¶‡§∏‡•ç‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§\n"
        "`/quote`: ‡§è‡§ï ‡§™‡•ç‡§∞‡•á‡§∞‡§£‡§æ‡§¶‡§æ‡§Ø‡§ï ‡§ï‡•ã‡§ü ‡§™‡§æ‡§è‡§Ç‡•§"
    )
    buttons = [[InlineKeyboardButton("üîô ‡§µ‡§æ‡§™‡§∏", callback_data="show_help")]]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("help_info"))
async def help_info_callback(_, callback_query):
    text = (
        "‚ÑπÔ∏è **‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏**\n\n"
        "`/stats`: ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§ü‡•â‡§™ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§∏‡•á‡§Ç‡§°‡§∞‡•ç‡§∏ ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§\n"
        "`/admins`: ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§∏‡§≠‡•Ä ‡§è‡§°‡§Æ‡§ø‡§® ‡§ï‡•ã ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/info <reply>`: ‡§ï‡§ø‡§∏‡•Ä ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§™‡§æ‡§è‡§Ç‡•§\n"
        "`/chatinfo`: ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§™‡§æ‡§è‡§Ç‡•§\n"
        "`/ping`: ‡§¨‡•â‡§ü ‡§ï‡•Ä ‡§ó‡§§‡§ø (speed) ‡§ï‡•ã ‡§ö‡•á‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§"
    )
    buttons = [[InlineKeyboardButton("üîô ‡§µ‡§æ‡§™‡§∏", callback_data="show_help")]]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("go_back"))
async def go_back_callback(_, callback_query):
    user_id = callback_query.from_user.id
    raw_name = callback_query.from_user.first_name or ""
    styled_name = to_bold_unicode(raw_name)

    caption = (
        f"üëã **‡§®‡§Æ‡§∏‡•ç‡§§‡•á {styled_name}!**\n\n"
        f"‡§Æ‡•à‡§Ç ‡§è‡§ï ‡§è‡§°‡§µ‡§æ‡§Ç‡§∏ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•à‡§®‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§Ö‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§π‡•Ç‡§Å‡•§\n"
        f"‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•ã ‡§∏‡§æ‡§´, ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§î‡§∞ ‡§µ‡•ç‡§Ø‡§µ‡§∏‡•ç‡§•‡§ø‡§§ ‡§∞‡§ñ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡§æ ‡§π‡•Ç‡§Å‡•§\n\n"
        f"‡§Æ‡•á‡§∞‡•á ‡§∏‡§≠‡•Ä ‡•û‡•Ä‡§ö‡§∞‡•ç‡§∏ ‡§ï‡•ã ‡§è‡§ï‡•ç‡§∏‡§™‡•ç‡§≤‡•ã‡§∞ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è **Help** ‡§¨‡§ü‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§\n\n"
        f"**Developer:** [Shubham](tg://user?id={OWNER_ID})"
    )
    buttons = [
        [
            InlineKeyboardButton("‚ûï ‡§Æ‡•Å‡§ù‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§ú‡•ã‡§°‡§º‡•á‡§Ç", url=f"https://t.me/{bot.get_me().username}?startgroup=true"),
            InlineKeyboardButton("üì¢ ‡§Ö‡§™‡§°‡•á‡§ü‡•ç‡§∏", url="https://t.me/vibeshiftbots")
        ],
        [
            InlineKeyboardButton("‚ùì Help", callback_data="show_help"),
            InlineKeyboardButton("üí¨ ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü", url="https://t.me/Frozensupport1")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_caption(
        caption=caption,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )
# --- Welcome/Onboarding Feature ---
@bot.on_message(filters.new_chat_members)
async def welcome_new_member(client, message):
    chat_id = message.chat.id
    for member in message.new_chat_members:
        if member.is_bot:
            continue
        
        if chat_id in custom_welcome_messages:
            welcome_text = custom_welcome_messages[chat_id]
        else:
            welcome_text = (
                f"üëã **{member.first_name}** ‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à! üéâ\n\n"
                "‡§ï‡•É‡§™‡§Ø‡§æ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§á‡§® ‡§®‡§ø‡§Ø‡§Æ‡•ã‡§Ç ‡§ï‡§æ ‡§™‡§æ‡§≤‡§® ‡§ï‡§∞‡•á‡§Ç:\n"
                "1. ‡§ï‡•ã‡§à ‡§∏‡•ç‡§™‡•à‡§Æ‡§ø‡§Ç‡§ó ‡§®‡§π‡•Ä‡§Ç\n"
                "2. ‡§ï‡•ã‡§à ‡§ó‡§æ‡§≤‡•Ä-‡§ó‡§≤‡•å‡§ú ‡§®‡§π‡•Ä‡§Ç\n"
                "3. ‡§ï‡•á‡§µ‡§≤ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§∏‡§Ç‡§¨‡§Ç‡§ß‡§ø‡§§ ‡§¨‡§æ‡§§‡•á‡§Ç ‡§ï‡§∞‡•á‡§Ç‡•§"
            )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úÖ ‡§Æ‡•à‡§Ç‡§®‡•á ‡§®‡§ø‡§Ø‡§Æ ‡§™‡§¢‡§º ‡§≤‡§ø‡§è ‡§π‡•à‡§Ç", callback_data="rules_accepted")]
        ])
        await client.send_message(chat_id, welcome_text, reply_markup=keyboard)

@bot.on_message(filters.group & filters.command("setwelcome"))
async def set_welcome_message(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§")
    
    parts = message.text.split(" ", 1)
    if len(parts) < 2:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§π ‡§Æ‡•à‡§∏‡•á‡§ú ‡§¶‡•á‡§Ç ‡§ú‡§ø‡§∏‡•á ‡§Ü‡§™ ‡§µ‡•á‡§≤‡§ï‡§Æ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§¨‡§®‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§")
    
    custom_welcome_messages[message.chat.id] = parts[1]
    await message.reply("‚úÖ ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§µ‡•á‡§≤‡§ï‡§Æ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§∏‡•á‡§ü ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")

@bot.on_callback_query(filters.regex("rules_accepted"))
async def handle_rules_accepted(client, callback_query):
    user_id = callback_query.from_user.id
    message = callback_query.message
    
    if len(message.entities) > 1 and message.entities[1].type == "text_mention":
        joined_user_id = message.entities[1].user.id
        if joined_user_id != user_id:
            await callback_query.answer("‚ùå ‡§Ü‡§™ ‡§ï‡§ø‡§∏‡•Ä ‡§î‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ø‡§π ‡§¨‡§ü‡§® ‡§®‡§π‡•Ä‡§Ç ‡§¶‡§¨‡§æ ‡§∏‡§ï‡§§‡•á‡•§", show_alert=True)
            return

    await callback_query.answer("‚úÖ ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ü‡§™ ‡§Ö‡§¨ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§≠‡§æ‡§ó ‡§≤‡•á ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§", show_alert=False)
    try:
        await callback_query.message.delete()
    except Exception as e:
        print(f"Error deleting welcome message: {e}")

# --- Moderation Commands ---
@bot.on_message(filters.group & filters.command("mute"))
async def mute_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
    
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.restrict_chat_member(
            chat_id=message.chat.id,
            user_id=target_user.id,
            permissions=ChatPermissions(can_send_messages=False)
        )
        await message.reply(f"üîá ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action("Mute", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("unmute"))
async def unmute_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.unban_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply(f"üîä ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§Ö‡§®‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action("Unmute", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§Ö‡§®‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("tmute"))
async def tmute_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
        
    parts = message.text.split()
    if len(parts) < 3:
        return await message.reply("‚ùå ‡§∏‡§π‡•Ä ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤: `/tmute <reply_to_user> <minutes>`")
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        mute_minutes = int(parts[2])
    except (IndexError, ValueError):
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§Æ‡§Ø ‡§Æ‡§ø‡§®‡§ü‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§Ç‡•§")

    mute_end_date = datetime.now(timezone.utc) + timedelta(minutes=mute_minutes)
    try:
        await client.restrict_chat_member(
            chat_id=message.chat.id,
            user_id=target_user.id,
            permissions=ChatPermissions(can_send_messages=False),
            until_date=mute_end_date
        )
        await message.reply(f"‚è±Ô∏è ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã {mute_minutes} ‡§Æ‡§ø‡§®‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action(f"Temporary Mute ({mute_minutes} mins)", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§Ö‡§∏‡•ç‡§•‡§æ‡§Ø‡•Ä ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("kick"))
async def kick_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.kick_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply("üö™ ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§ï‡§ø‡§ï ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action("Kick", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§ï‡§ø‡§ï ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("ban"))
async def ban_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.ban_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply("üö´ ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§¨‡•à‡§® ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action("Ban", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§¨‡•à‡§® ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("unban"))
async def unban_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.unban_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply("‚úÖ ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§Ö‡§®‡§¨‡•à‡§® ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action("Unban", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§Ö‡§®‡§¨‡•à‡§® ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("del"))
async def delete_message(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§")
    
    if not message.reply_to_message:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§â‡§∏ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§™‡§∞ ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç ‡§ú‡§ø‡§∏‡•á ‡§Ü‡§™ ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§")
    
    try:
        await client.delete_messages(message.chat.id, [message.reply_to_message.id, message.id])
    except Exception as e:
        await message.reply(f"‚ùå ‡§Æ‡•à‡§∏‡•á‡§ú ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

# --- Anti-Abuse & Security ---
@bot.on_message(filters.group & ~filters.me & ~filters.via_bot)
async def anti_abuse_filter(client, message):
    if message.from_user.id in gban_list:
        try:
            await client.ban_chat_member(message.chat.id, message.from_user.id)
            return
        except Exception:
            pass

    user_status = (await client.get_chat_member(message.chat.id, message.from_user.id)).status
    if user_status in [ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER]:
        return

    # Auto-mute for low message count
    user_id = message.from_user.id
    if user_id not in user_stats or user_stats[user_id].get('messages', 0) < LOW_MSG_MUTE_THRESHOLD:
        try:
            await client.restrict_chat_member(
                chat_id=message.chat.id,
                user_id=user_id,
                permissions=ChatPermissions(can_send_messages=False),
                until_date=datetime.now(timezone.utc) + timedelta(seconds=LOW_MSG_MUTE_TIME)
            )
            await message.reply(f"üîá **{message.from_user.first_name}** ‡§ï‡•ã ‡§ï‡•Å‡§õ ‡§¶‡•á‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™‡§ï‡•á ‡§Æ‡•à‡§∏‡•á‡§ú ‡§¨‡§π‡•Å‡§§ ‡§ï‡§Æ ‡§π‡•à‡§Ç‡•§ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§≠‡§æ‡§ó ‡§≤‡•á‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§î‡§∞ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§≠‡•á‡§ú‡•á‡§Ç‡•§")
        except Exception:
            pass
        return

    if message.forward_from or message.forward_from_chat:
        try:
            await message.delete()
        except Exception:
            pass

    if re.search(r'(https?://\S+|t\.me/\S+)', message.text or ''):
        try:
            await message.delete()
            await client.send_message(message.chat.id, f"‚ùå **{message.from_user.first_name}**, ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§≤‡§ø‡§Ç‡§ï ‡§≠‡•á‡§ú‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§")
        except Exception:
            pass

    profanity_list = ["fuck", "bitch", "cunt", "chutiya", "randi"]
    if any(word in (message.text or '').lower() for word in profanity_list):
        try:
            await message.delete()
            await client.send_message(message.chat.id, f"‚ùå **{message.from_user.first_name}**, ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§ê‡§∏‡•Ä ‡§≠‡§æ‡§∑‡§æ ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§® ‡§ï‡§∞‡•á‡§Ç‡•§")
        except Exception:
            pass

# --- Automations & Workflows ---
@bot.on_message(filters.group & filters.text & ~filters.via_bot & filters.regex(r'(?i)^(hi|hello|namaste|rules|help)$'))
async def automation_handler(client, message):
    if not message.text:
        return
    
    text = message.text.lower()
    
    if "hi" in text or "hello" in text or "namaste" in text:
        await message.reply(f"‡§®‡§Æ‡§∏‡•ç‡§§‡•á, **{message.from_user.first_name}**! üëã\n‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à‡•§")

    elif "rules" in text:
        await message.reply("‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§®‡§ø‡§Ø‡§Æ ‡§ú‡§æ‡§®‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è `/help` ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§")

    elif "help" in text:
        await message.reply("‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§¶‡§¶ ‡§ï‡•à‡§∏‡•á ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Å? `/help` ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è ‡§¨‡§ü‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§",
                            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùì Help Menu", callback_data="show_help")]]))

# --- New Features ---
@bot.on_message(filters.group & filters.command("quote"))
async def send_random_quote(_, message):
    quote = random.choice(QUOTES)
    await message.reply(f"üí¨ **Quote of the Day**\n\n{quote}")

@bot.on_message(filters.group & filters.command("gban") & filters.user(OWNER_ID))
async def global_ban(client, message):
    target_user = await extract_target_user(message)
    if not target_user:
        return
    
    gban_list.add(target_user.id)
    await message.reply(f"üö´ **{target_user.first_name}** ‡§ï‡•ã ‡§∏‡§≠‡•Ä ‡§ó‡•ç‡§∞‡•Å‡§™‡•ç‡§∏ ‡§∏‡•á ‡§¨‡•à‡§® ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")

@bot.on_message(filters.group & filters.command("ungban") & filters.user(OWNER_ID))
async def global_unban(client, message):
    target_user = await extract_target_user(message)
    if not target_user:
        return
    
    if target_user.id in gban_list:
        gban_list.remove(target_user.id)
        await message.reply(f"‚úÖ **{target_user.first_name}** ‡§ï‡•ã ‡§ó‡•ç‡§≤‡•ã‡§¨‡§≤ ‡§¨‡•à‡§® ‡§∏‡•á ‡§π‡§ü‡§æ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
    else:
        await message.reply("‚ùå ‡§Ø‡§π ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ó‡•ç‡§≤‡•ã‡§¨‡§≤ ‡§¨‡•à‡§® ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡•á‡§Ç ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§")

@bot.on_message(filters.group & filters.command("save"))
async def save_note(_, message):
    parts = message.text.split(" ", 2)
    if len(parts) < 3:
        return await message.reply("‚ùå ‡§∏‡§π‡•Ä ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤: `/save <note_name> <text>`")
    
    note_name = parts[1].lower()
    note_text = parts[2]
    
    if note_name in notes_data:
        return await message.reply("‚ùå ‡§á‡§∏ ‡§®‡§æ‡§Æ ‡§ï‡§æ ‡§®‡•ã‡§ü ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§Æ‡•å‡§ú‡•Ç‡§¶ ‡§π‡•à‡•§")
        
    notes_data[note_name] = note_text
    await message.reply(f"‚úÖ ‡§®‡•ã‡§ü `{note_name}` ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§∏‡•á‡§µ ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")

@bot.on_message(filters.group & filters.command("notes"))
async def get_notes(_, message):
    if not notes_data:
        return await message.reply("‚ùå ‡§Ö‡§≠‡•Ä ‡§§‡§ï ‡§ï‡•ã‡§à ‡§®‡•ã‡§ü ‡§∏‡•á‡§µ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•Å‡§Ü ‡§π‡•à‡•§")
    
    notes_list = "\n".join(notes_data.keys())
    await message.reply(f"üìù **‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡•ã‡§ü‡•ç‡§∏:**\n\n`{notes_list}`")

@bot.on_message(filters.group & filters.command("getnotes"))
async def get_note(_, message):
    parts = message.text.split(" ", 1)
    if len(parts) < 2:
        return await message.reply("‚ùå ‡§∏‡§π‡•Ä ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤: `/getnotes <note_name>`")
    
    note_name = parts[1].lower()
    
    if note_name not in notes_data:
        return await message.reply("‚ùå ‡§á‡§∏ ‡§®‡§æ‡§Æ ‡§ï‡§æ ‡§ï‡•ã‡§à ‡§®‡•ã‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§")
        
    await message.reply(notes_data[note_name])

@bot.on_message(filters.group & filters.command("deletenote"))
async def delete_note(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§")
    
    parts = message.text.split(" ", 1)
    if len(parts) < 2:
        return await message.reply("‚ùå ‡§∏‡§π‡•Ä ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤: `/deletenote <note_name>`")
    
    note_name = parts[1].lower()
    
    if note_name not in notes_data:
        return await message.reply("‚ùå ‡§á‡§∏ ‡§®‡§æ‡§Æ ‡§ï‡§æ ‡§ï‡•ã‡§à ‡§®‡•ã‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§")
        
    del notes_data[note_name]
    await message.reply(f"‚úÖ ‡§®‡•ã‡§ü `{note_name}` ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")

@bot.on_message(filters.group & filters.command("admins"))
async def list_admins(client, message):
    admins = []
    async for member in client.get_chat_members(message.chat.id, filter="administrators"):
        admins.append(f"**{member.user.first_name}** (`{member.user.id}`)")
        
    if not admins:
        return await message.reply("‚ùå ‡§á‡§∏ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§ï‡•ã‡§à ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§")
        
    admins_text = "üõ°Ô∏è **‡§ó‡•ç‡§∞‡•Å‡§™ ‡§è‡§°‡§Æ‡§ø‡§®:**\n\n" + "\n".join(admins)
    await message.reply(admins_text)

@bot.on_message(filters.group & filters.command("ping"))
async def ping_command(_, message):
    start_time = time.time()
    await message.reply(" pong!")
    end_time = time.time()
    latency = round((end_time - start_time) * 1000)
    await message.edit_text(f"üöÄ **Pong!**\n`{latency}ms`")

# --- All other features (already implemented) ---
# ... (all other commands from the previous update go here)
# Since the code block is too large, I'm showing a placeholder. You should paste all the previous code here.

# --- Voice to Text (VTT) ---
@bot.on_message(filters.group & filters.command("vtt"))
async def voice_to_text_command(client, message):
    if not message.reply_to_message or not message.reply_to_message.voice:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§µ‡•â‡§á‡§∏ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§™‡§∞ ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç‡•§")

    try:
        await message.reply("üîÑ ‡§ü‡•ç‡§∞‡§æ‡§Ç‡§∏‡§ï‡•ç‡§∞‡§æ‡§á‡§¨ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à... ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ï‡§∞‡•á‡§Ç‡•§")
        voice_file_path = await message.reply_to_message.download()

        audio = AudioSegment.from_ogg(voice_file_path)
        audio.export("voice.wav", format="wav")

        recognizer = sr.Recognizer()
        with sr.AudioFile("voice.wav") as source:
            audio_data = recognizer.record(source)
            text = recognizer.recognize_google(audio_data, language="hi-IN")
            await message.reply(f"üé§ **‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü:** `{text}`")

    except sr.UnknownValueError:
        await message.reply("‚ùå ‡§µ‡•â‡§á‡§∏ ‡§ï‡•ã ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§∏‡§ï‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§¨‡•ã‡§≤‡•á‡§Ç‡•§")
    except Exception as e:
        await message.reply(f"‚ùå ‡§µ‡•â‡§á‡§∏ ‡§ï‡•ã ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")
    finally:
        if os.path.exists(voice_file_path):
            os.remove(voice_file_path)
        if os.path.exists("voice.wav"):
            os.remove("voice.wav")

# ... (All other command handlers like poll, remindme, couple, etc.)

if __name__ == "__main__":
    print("Bot started. Press Ctrl+C to stop.")
    asyncio.get_event_loop().create_task(send_scheduled_messages())
    asyncio.get_event_loop().create_task(check_auto_delete())
    bot.run()
