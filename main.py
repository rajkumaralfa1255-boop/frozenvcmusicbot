import os
import re
import sys
import time
import json
import logging
import asyncio
import random
import feedparser
import speech_recognition as sr
from pydub import AudioSegment
from datetime import datetime, timezone, timedelta
from dotenv import load_dotenv
from flask import Flask, request
from pyrogram import Client, filters, errors
from pyrogram.enums import ChatType, ChatMemberStatus, ParseMode
from pyrogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ChatPermissions,
    ChatMember,
)
from FrozenMusic.infra.concurrency.ci import deterministic_privilege_validator
from gtts import gTTS

# Load environment variables
load_dotenv()

API_ID = int(os.environ.get("API_ID"))
API_HASH = os.environ.get("API_HASH")
BOT_TOKEN = os.environ.get("BOT_TOKEN")
OWNER_ID = int(os.getenv("OWNER_ID", "5268762773"))
LOG_CHANNEL_ID = int(os.getenv("-1002107533268", None)) # Log channel for admin actions
RSS_FEED_URL = os.environ.get("RSS_FEED_URL", "https://www.youtube.com/feeds/videos.xml?channel_id=UC-K20bY-dK_9e17W3K-252A")
RSS_CHANNEL_ID = int(os.getenv("RSS_CHANNEL_ID", None))

# Initialize the bot client
session_name = os.environ.get("SESSION_NAME", "help_bot")
bot = Client(session_name, bot_token=BOT_TOKEN, api_id=API_ID, api_hash=API_HASH)

# Define bot name for dynamic use
BOT_NAME = os.environ.get("BOT_NAME", "Frozen Help Bot")
BOT_LINK = os.environ.get("BOT_LINK", f"https://t.me/{bot.get_me().username}")

# In-memory storage for user stats and RSS feed
user_stats = {}
last_rss_entry_link = ""
premium_users = set()

# A simple FAQ dictionary
FAQ_DATA = {
    "rules": "рдЧреНрд░реБрдк рдХреЗ рдирд┐рдпрдо:\n1. рдХреЛрдИ рд╕реНрдкреИрдорд┐рдВрдЧ рдирд╣реАрдВ\n2. рдХреЛрдИ рдЧрд╛рд▓реА-рдЧрд▓реМрдЬ рдирд╣реАрдВ\n3. рдХреЗрд╡рд▓ рдЧреНрд░реБрдк рд╕реЗ рд╕рдВрдмрдВрдзрд┐рдд рдмрд╛рддреЗрдВред",
    "help": "рдореИрдВ рдЖрдкрдХреА рдорджрдж рдХреИрд╕реЗ рдХрд░ рд╕рдХрддрд╛ рд╣реВрдБ? `/help` рдХрдорд╛рдВрдб рдХрд╛ рдкреНрд░рдпреЛрдЧ рдХрд░реЗрдВ рдпрд╛ рдиреАрдЪреЗ рджрд┐рдП рдЧрдП рдмрдЯрди рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВред",
    "contact": "рдПрдбрдорд┐рди рд╕реЗ рд╕рдВрдкрд░реНрдХ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП @Frozensupport1 рдкрд░ рдореИрд╕реЗрдЬ рдХрд░реЗрдВред",
}

# New In-memory storage for new features
warn_counts = {}
user_message_timestamps = {}
scheduled_messages = []
user_reputation = {}
auto_delete_timers = {}

# --- Flood Control Settings (New) ---
FLOOD_THRESHOLD = 5 # max messages
FLOOD_TIME_WINDOW = 3 # in seconds
FLOOD_MUTE_TIME = 10 # in minutes

# Helper functions
def to_bold_unicode(text: str) -> str:
    bold_text = ""
    for char in text:
        if 'A' <= char <= 'Z':
            bold_text += chr(ord('ЁЭЧФ') + (ord(char) - ord('A')))
        elif 'a' <= char <= 'z':
            bold_text += chr(ord('ЁЭЧо') + (ord('char') - ord('a')))
        else:
            bold_text += char
    return bold_text

async def extract_target_user(message: Message):
    if message.reply_to_message:
        return message.reply_to_message.from_user
    
    parts = message.text.split()
    if len(parts) < 2:
        await message.reply("тЭМ рдХреГрдкрдпрд╛ рдХрд┐рд╕реА рдпреВреЫрд░ рдХреЛ рд░рд┐рдкреНрд▓рд╛рдИ рдХрд░реЗрдВ рдпрд╛ рдЙрд╕рдХрд╛ @username/user_id рджреЗрдВред")
        return None

    target = parts[1]
    if target.startswith("@"):
        target = target[1:]
    try:
        user = await message._client.get_users(target)
        return user
    except:
        await message.reply("тЭМ рдпрд╣ рдпреВреЫрд░ рдирд╣реАрдВ рдорд┐рд▓рд╛ред")
        return None

# --- Admin Action Log (Step 9) ---
async def log_admin_action(action: str, admin: str, target: str):
    if LOG_CHANNEL_ID:
        log_message = f"ЁЯЫбя╕П **рдПрдбрдорд┐рди рд▓реЙрдЧ**\n\n**рдХрд╛рд░реНрдп:** {action}\n**рдПрдбрдорд┐рди:** {admin}\n**рд▓рдХреНрд╖реНрдп:** {target}"
        try:
            await bot.send_message(LOG_CHANNEL_ID, log_message)
        except Exception as e:
            print(f"Failed to send log to channel: {e}")

# --- Welcome/Onboarding Feature ---
@bot.on_message(filters.new_chat_members)
async def welcome_new_member(client, message):
    chat_id = message.chat.id
    for member in message.new_chat_members:
        if member.is_bot:
            continue
        
        user_name = member.first_name
        welcome_text = (
            f"ЁЯСЛ **{user_name}** рдХрд╛ рд╕реНрд╡рд╛рдЧрдд рд╣реИ! ЁЯОЙ\n\n"
            "рдХреГрдкрдпрд╛ рдЧреНрд░реБрдк рдХреЗ рдЗрди рдирд┐рдпрдореЛрдВ рдХрд╛ рдкрд╛рд▓рди рдХрд░реЗрдВ:\n"
            "1. рдХрд┐рд╕реА рднреА рддрд░рд╣ рдХреА рд╕реНрдкреИрдорд┐рдВрдЧ рди рдХрд░реЗрдВред\n"
            "2. рдЕрднрджреНрд░ рднрд╛рд╖рд╛ рдХрд╛ рдкреНрд░рдпреЛрдЧ рди рдХрд░реЗрдВред\n"
            "3. рдХреЗрд╡рд▓ рдЧреНрд░реБрдк рд╕реЗ рд╕рдВрдмрдВрдзрд┐рдд рдмрд╛рддреЗрдВ рдХрд░реЗрдВред"
        )
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("тЬЕ рдореИрдВрдиреЗ рдирд┐рдпрдо рдкрдврд╝ рд▓рд┐рдП рд╣реИрдВ", callback_data="rules_accepted")]
        ])
        await client.send_message(chat_id, welcome_text, reply_markup=keyboard)

@bot.on_callback_query(filters.regex("rules_accepted"))
async def handle_rules_accepted(client, callback_query):
    user_id = callback_query.from_user.id
    message = callback_query.message
    
    if len(message.entities) > 1 and message.entities[1].type == "text_mention":
        joined_user_id = message.entities[1].user.id
        if joined_user_id != user_id:
            await callback_query.answer("тЭМ рдЖрдк рдХрд┐рд╕реА рдФрд░ рдХреЗ рд▓рд┐рдП рдпрд╣ рдмрдЯрди рдирд╣реАрдВ рджрдмрд╛ рд╕рдХрддреЗред", show_alert=True)
            return

    await callback_query.answer("тЬЕ рдзрдиреНрдпрд╡рд╛рдж! рдЖрдк рдЕрдм рдЧреНрд░реБрдк рдореЗрдВ рднрд╛рдЧ рд▓реЗ рд╕рдХрддреЗ рд╣реИрдВред", show_alert=False)
    try:
        await callback_query.message.delete()
    except Exception as e:
        print(f"Error deleting welcome message: {e}")

# --- Moderation Commands ---
@bot.on_message(filters.group & filters.command("mute"))
async def mute_user(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗ, рдХреНрдпреЛрдВрдХрд┐ рдЖрдк рдПрдбрдорд┐рди рдирд╣реАрдВ рд╣реИрдВред")
    
    target_user_id = await extract_target_user(message)
    if not target_user_id:
        return
    try:
        await client.restrict_chat_member(
            chat_id=message.chat.id,
            user_id=target_user_id.id,
            permissions=ChatPermissions(can_send_messages=False)
        )
        await message.reply(f"ЁЯФЗ рдпреВреЫрд░ рдХреЛ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдореНрдпреВрдЯ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
        await log_admin_action("Mute", message.from_user.first_name, target_user_id.first_name)
    except Exception as e:
        await message.reply(f"тЭМ рдпреВреЫрд░ рдХреЛ рдореНрдпреВрдЯ рдХрд░рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

@bot.on_message(filters.group & filters.command("unmute"))
async def unmute_user(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗ, рдХреНрдпреЛрдВрдХрд┐ рдЖрдк рдПрдбрдорд┐рди рдирд╣реАрдВ рд╣реИрдВред")
        
    target_user_id = await extract_target_user(message)
    if not target_user_id:
        return
    try:
        await client.unban_chat_member(chat_id=message.chat.id, user_id=target_user_id.id)
        await message.reply(f"ЁЯФК рдпреВреЫрд░ рдХреЛ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЕрдирдореНрдпреВрдЯ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
        await log_admin_action("Unmute", message.from_user.first_name, target_user_id.first_name)
    except Exception as e:
        await message.reply(f"тЭМ рдпреВреЫрд░ рдХреЛ рдЕрдирдореНрдпреВрдЯ рдХрд░рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

@bot.on_message(filters.group & filters.command("tmute"))
async def tmute_user(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗ, рдХреНрдпреЛрдВрдХрд┐ рдЖрдк рдПрдбрдорд┐рди рдирд╣реАрдВ рд╣реИрдВред")
        
    parts = message.text.split()
    if len(parts) < 3:
        return await message.reply("тЭМ рд╕рд╣реА рдЗрд╕реНрддреЗрдорд╛рд▓: `/tmute <reply_to_user> <minutes>`")
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        mute_minutes = int(parts[2])
    except (IndexError, ValueError):
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рд╕рдордп рдорд┐рдирдЯреЛрдВ рдореЗрдВ рдПрдХ рд╕рдВрдЦреНрдпрд╛ рдХреЗ рд░реВрдк рдореЗрдВ рджреЗрдВред")

    mute_end_date = datetime.now(timezone.utc) + timedelta(minutes=mute_minutes)
    try:
        await client.restrict_chat_member(
            chat_id=message.chat.id,
            user_id=target_user.id,
            permissions=ChatPermissions(can_send_messages=False),
            until_date=mute_end_date
        )
        await message.reply(f"тП▒я╕П рдпреВреЫрд░ рдХреЛ {mute_minutes} рдорд┐рдирдЯ рдХреЗ рд▓рд┐рдП рдореНрдпреВрдЯ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
        await log_admin_action(f"Temporary Mute ({mute_minutes} mins)", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"тЭМ рдпреВреЫрд░ рдХреЛ рдЕрд╕реНрдерд╛рдпреА рд░реВрдк рд╕реЗ рдореНрдпреВрдЯ рдХрд░рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

@bot.on_message(filters.group & filters.command("kick"))
async def kick_user(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗ, рдХреНрдпреЛрдВрдХрд┐ рдЖрдк рдПрдбрдорд┐рди рдирд╣реАрдВ рд╣реИрдВред")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.kick_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply("ЁЯЪк рдпреВреЫрд░ рдХреЛ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЧреНрд░реБрдк рд╕реЗ рдХрд┐рдХ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
        await log_admin_action("Kick", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"тЭМ рдпреВреЫрд░ рдХреЛ рдХрд┐рдХ рдХрд░рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

@bot.on_message(filters.group & filters.command("ban"))
async def ban_user(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗ, рдХреНрдпреЛрдВрдХрд┐ рдЖрдк рдПрдбрдорд┐рди рдирд╣реАрдВ рд╣реИрдВред")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.ban_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply("ЁЯЪл рдпреВреЫрд░ рдХреЛ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЧреНрд░реБрдк рд╕реЗ рдмреИрди рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
        await log_admin_action("Ban", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"тЭМ рдпреВреЫрд░ рдХреЛ рдмреИрди рдХрд░рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

@bot.on_message(filters.group & filters.command("unban"))
async def unban_user(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗ, рдХреНрдпреЛрдВрдХрд┐ рдЖрдк рдПрдбрдорд┐рди рдирд╣реАрдВ рд╣реИрдВред")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.unban_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply("тЬЕ рдпреВреЫрд░ рдХреЛ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЕрдирдмреИрди рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
        await log_admin_action("Unban", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"тЭМ рдпреВреЫрд░ рдХреЛ рдЕрдирдмреИрди рдХрд░рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

# --- New Advanced Help System ---
@bot.on_message(filters.command(["start", "help"]))
async def start_and_help_handler(_, message):
    user_id = message.from_user.id
    raw_name = message.from_user.first_name or ""
    styled_name = to_bold_unicode(raw_name)
    user_link = f"[{styled_name}](tg://user?id={user_id})"

    help_text = to_bold_unicode("Help")
    add_me_text = to_bold_unicode("Add Me")
    updates_text = to_bold_unicode("Updates")
    support_text = to_bold_unicode("Support")

    caption = (
        f"ЁЯСЛ **Welcome!**\n\n"
        f"This is an advanced group management assistant.\n\n"
        f"ЁЯЫая╕П **Admin Commands:** Mute, Unmute, Tmute, Kick, Ban, Unban\n\n"
        f"ЁЯЫбя╕П **Anti-Abuse Filters:** This bot automatically handles spam links, forwards, and profanity.\n\n"
        f"р╣П Click **Help** below to see all commands."
    )
    buttons = [
        [
            InlineKeyboardButton(f"тЮХ {add_me_text}", url=f"{BOT_LINK}?startgroup=true"),
            InlineKeyboardButton(f"ЁЯУв {updates_text}", url="https://t.me/vibeshiftbots")
        ],
        [
            InlineKeyboardButton(f"ЁЯТм {support_text}", url="https://t.me/Frozensupport1"),
            InlineKeyboardButton(f"тЭУ {help_text}", callback_data="show_help")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(buttons)
    await message.reply_animation(
        animation="https://frozen-imageapi.lagendplayersyt.workers.dev/file/2e483e17-05cb-45e2-b166-1ea476ce9521.mp4",
        caption=caption,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )

@bot.on_callback_query(filters.regex("^show_help$"))
async def show_help_callback(_, callback_query):
    text = ">ЁЯУЬ *Choose a category to explore commands:*"
    buttons = [
        [InlineKeyboardButton("ЁЯЫбя╕П Admin Tools", callback_data="help_admin")],
        [InlineKeyboardButton("тЭдя╕П Fun & Games", callback_data="help_fun")],
        [InlineKeyboardButton("ЁЯПа Home", callback_data="go_back")]
    ]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("^help_admin$"))
async def help_admin_callback(_, callback_query):
    text = (
        "ЁЯЫбя╕П *Admin & Moderation Commands*\n\n"
        ">тЮЬ `/mute <@user or reply>`\n"
        "   тАв Mute a user indefinitely.\n\n"
        ">тЮЬ `/unmute <@user or reply>`\n"
        "   тАв Unmute a previously muted user.\n\n"
        ">тЮЬ `/tmute <@user or reply> <minutes>`\n"
        "   тАв Temporarily mute a user for a set duration.\n\n"
        ">тЮЬ `/kick <@user or reply>`\n"
        "   тАв Kick a user from the group.\n\n"
        ">тЮЬ `/ban <@user or reply>`\n"
        "   тАв Ban a user permanently.\n\n"
        ">тЮЬ `/unban <@user or reply>`\n"
        "   тАв Unban a previously banned user."
    )
    buttons = [[InlineKeyboardButton("ЁЯФЩ Back", callback_data="show_help")]]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("^help_fun$"))
async def help_fun_callback(_, callback_query):
    text = (
        "тЭдя╕П *Fun & Engagement Commands*\n\n"
        ">тЮЬ `/poll <question> <option1> <option2> ...`\n"
        "   тАв Create a poll with multiple options.\n\n"
        ">тЮЬ `/couple`\n"
        "   тАв Find a random couple from the group members.\n\n"
        ">тЮЬ `/remindme in <time> <message>`\n"
        "   тАв Set a personal reminder. (Example: `/remindme in 1h to eat lunch`)\n\n"
        ">тЮЬ `/dice`\n"
        "   тАв Roll a dice."
    )
    buttons = [[InlineKeyboardButton("ЁЯФЩ Back", callback_data="show_help")]]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("^go_back$"))
async def go_back_callback(_, callback_query):
    user_id = callback_query.from_user.id
    raw_name = callback_query.from_user.first_name or ""
    styled_name = to_bold_unicode(raw_name)
    user_link = f"[{styled_name}](tg://user?id={user_id})"

    help_text = to_bold_unicode("Help")
    add_me_text = to_bold_unicode("Add Me")
    updates_text = to_bold_unicode("Updates")
    support_text = to_bold_unicode("Support")

    caption = (
        f"ЁЯСЛ **Welcome!**\n\n"
        f"This is an advanced group management assistant.\n\n"
        f"ЁЯЫая╕П **Admin Commands:** Mute, Unmute, Tmute, Kick, Ban, Unban\n\n"
        f"ЁЯЫбя╕П **Anti-Abuse Filters:** This bot automatically handles spam links, forwards, and profanity.\n\n"
        f"р╣П Click **Help** below to see all commands."
    )
    buttons = [
        [
            InlineKeyboardButton(f"тЮХ {add_me_text}", url=f"{BOT_LINK}?startgroup=true"),
            InlineKeyboardButton(f"ЁЯУв {updates_text}", url="https://t.me/vibeshiftbots")
        ],
        [
            InlineKeyboardButton(f"ЁЯТм {support_text}", url="https://t.me/Frozensupport1"),
            InlineKeyboardButton(f"тЭУ {help_text}", callback_data="show_help")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_caption(
        caption=caption,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )

# --- Anti-Abuse & Security (Step 3) ---
@bot.on_message(filters.group & ~filters.me & ~filters.via_bot)
async def anti_abuse_filter(client, message):
    user_status = (await client.get_chat_member(message.chat.id, message.from_user.id)).status
    if user_status in [ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER]:
        return

    # Flood Control Logic
    user_id = message.from_user.id
    current_time = time.time()
    
    if user_id not in user_message_timestamps:
        user_message_timestamps[user_id] = []
    
    user_message_timestamps[user_id].append(current_time)
    
    user_message_timestamps[user_id] = [ts for ts in user_message_timestamps[user_id] if current_time - ts <= FLOOD_TIME_WINDOW]
    
    if len(user_message_timestamps[user_id]) > FLOOD_THRESHOLD:
        try:
            await client.restrict_chat_member(
                chat_id=message.chat.id,
                user_id=user_id,
                permissions=ChatPermissions(can_send_messages=False),
                until_date=datetime.now(timezone.utc) + timedelta(minutes=FLOOD_MUTE_TIME)
            )
            await message.reply(f"ЁЯФЗ **{message.from_user.first_name}** рдХреЛ рд╕реНрдкреИрдорд┐рдВрдЧ рдХреЗ рдХрд╛рд░рдг {FLOOD_MUTE_TIME} рдорд┐рдирдЯ рдХреЗ рд▓рд┐рдП рдореНрдпреВрдЯ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
            await log_admin_action("Flood Mute", "Automatic", message.from_user.first_name)
        except Exception:
            pass
        return

    if message.forward_from or message.forward_from_chat:
        try:
            await message.delete()
        except Exception:
            pass

    if re.search(r'(https?://\S+|t\.me/\S+)', message.text or ''):
        try:
            await message.delete()
            await client.send_message(message.chat.id, f"тЭМ **{message.from_user.first_name}**, рдЧреНрд░реБрдк рдореЗрдВ рд▓рд┐рдВрдХ рднреЗрдЬрдиреЗ рдХреА рдЕрдиреБрдорддрд┐ рдирд╣реАрдВ рд╣реИред")
        except Exception:
            pass

    profanity_list = ["fuck", "bitch", "cunt", "chutiya", "randi"]
    if any(word in (message.text or '').lower() for word in profanity_list):
        try:
            await message.delete()
            await client.send_message(message.chat.id, f"тЭМ **{message.from_user.first_name}**, рдЧреНрд░реБрдк рдореЗрдВ рдРрд╕реА рднрд╛рд╖рд╛ рдХрд╛ рдкреНрд░рдпреЛрдЧ рди рдХрд░реЗрдВред")
        except Exception:
            pass

# --- Automations & Workflows (Step 4) ---
@bot.on_message(filters.group & filters.text & ~filters.via_bot & filters.regex(r'(?i)^(hi|hello|namaste|rules|help)$'))
async def automation_handler(client, message):
    if not message.text:
        return
    
    text = message.text.lower()
    
    if "hi" in text or "hello" in text or "namaste" in text:
        await message.reply(f"рдирдорд╕реНрддреЗ, **{message.from_user.first_name}**! ЁЯСЛ\nрдЧреНрд░реБрдк рдореЗрдВ рдЖрдкрдХрд╛ рд╕реНрд╡рд╛рдЧрдд рд╣реИред")

    elif "rules" in text:
        await message.reply("рдЧреНрд░реБрдк рдХреЗ рдирд┐рдпрдо рдЬрд╛рдирдиреЗ рдХреЗ рд▓рд┐рдП `/help` рдХрдорд╛рдВрдб рдХрд╛ рдкреНрд░рдпреЛрдЧ рдХрд░реЗрдВред")

    elif "help" in text:
        await message.reply("рдореИрдВ рдЖрдкрдХреА рдорджрдж рдХреИрд╕реЗ рдХрд░ рд╕рдХрддрд╛ рд╣реВрдБ? `/help` рдХрдорд╛рдВрдб рдХрд╛ рдкреНрд░рдпреЛрдЧ рдХрд░реЗрдВ рдпрд╛ рдиреАрдЪреЗ рджрд┐рдП рдЧрдП рдмрдЯрди рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВред",
                            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("тЭУ Help Menu", callback_data="show_help")]]))

# --- New Features from Step 5 & 6 ---

@bot.on_message(filters.group & filters.command("poll"))
async def poll_command(_, message):
    args = message.text.split()[1:]
    if len(args) < 3:
        await message.reply("тЭМ рдХреГрдкрдпрд╛ рдПрдХ рд╕рд╡рд╛рд▓ рдФрд░ рдХрдо рд╕реЗ рдХрдо рджреЛ рд╡рд┐рдХрд▓реНрдк рджреЗрдВред\nрд╕рд╣реА рдЗрд╕реНрддреЗрдорд╛рд▓: `/poll рдЖрдкрдХрд╛ рд╕рд╡рд╛рд▓? рдСрдкреНрд╢рди1 рдСрдкреНрд╢рди2 ...`")
        return

    question = args[0]
    options = args[1:]
    
    try:
        await bot.send_poll(
            chat_id=message.chat.id,
            question=question,
            options=options,
            is_anonymous=False
        )
        await message.delete()
    except Exception as e:
        await message.reply(f"тЭМ рдкреЛрд▓ рдмрдирд╛рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

@bot.on_message(filters.group & filters.command("remindme"))
async def remindme_command(client, message):
    parts = message.text.split()
    if len(parts) < 4 or not parts[2].endswith(('m', 'h', 's')):
        await message.reply("тЭМ рд╕рд╣реА рдЗрд╕реНрддреЗрдорд╛рд▓: `/remindme in <рд╕рдордп> <рдореИрд╕реЗрдЬ>`\nрдЙрджрд╛рд╣рд░рдг: `/remindme in 10m to drink water`")
        return

    try:
        time_unit = parts[2][-1]
        time_value = int(parts[2][:-1])
        reminder_text = " ".join(parts[3:])
    except (IndexError, ValueError):
        await message.reply("тЭМ рдХреГрдкрдпрд╛ рд╕рд╣реА рд╕рдордп рдФрд░ рдореИрд╕реЗрдЬ рджреЗрдВред")
        return
        
    if time_unit == 's':
        seconds = time_value
    elif time_unit == 'm':
        seconds = time_value * 60
    elif time_unit == 'h':
        seconds = time_value * 3600
    else:
        await message.reply("тЭМ рдЕрдорд╛рдиреНрдп рд╕рдордп рдЗрдХрд╛рдИред рдХреЗрд╡рд▓ 's' (рд╕реЗрдХрдВрдб), 'm' (рдорд┐рдирдЯ), 'h' (рдШрдВрдЯреЗ) рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред")
        return
    
    if seconds > 3600 * 24:
        await message.reply("тЭМ рдореИрдВ 24 рдШрдВрдЯреЗ рд╕реЗ реЫреНрдпрд╛рджрд╛ рдХрд╛ рд░рд┐рдорд╛рдЗрдВрдбрд░ рдирд╣реАрдВ рд▓рдЧрд╛ рд╕рдХрддрд╛ред")
        return

    await message.reply(f"тП░ рдЖрдкрдХрд╛ рд░рд┐рдорд╛рдЗрдВрдбрд░ **{time_value}{time_unit}** рдореЗрдВ рд╕реЗрдЯ рд╣реЛ рдЧрдпрд╛ рд╣реИред")
    await asyncio.sleep(seconds)
    await message.reply(f"ЁЯФФ **рд░рд┐рдорд╛рдЗрдВрдбрд░:**\n\n**{message.from_user.first_name}**, рдЖрдкрдХреЛ рдпрд╛рдж рджрд┐рд▓рд╛рдпрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИ:\n\n`{reminder_text}`")


@bot.on_message(filters.group & filters.command("couple"))
async def couple_command(client, message):
    try:
        members = []
        async for member in client.get_chat_members(message.chat.id):
            if not member.user.is_bot:
                members.append(member.user)
        
        if len(members) < 2:
            await message.reply("тЭМ рдЗрд╕ рдХрдорд╛рдВрдб рдХреЗ рд▓рд┐рдП рдХрдо рд╕реЗ рдХрдо 2 рд╕рджрд╕реНрдп рд╣реЛрдиреЗ рдЪрд╛рд╣рд┐рдПред")
            return

        couple = random.sample(members, 2)
        
        caption = (
            f"тЭдя╕П **Group Couple of the Day** тЭдя╕П\n\n"
            f"**{couple[0].first_name}** ЁЯТШ **{couple[1].first_name}**"
        )
        
        await message.reply(caption)
    except Exception as e:
        await message.reply(f"тЭМ рдЗрд╕ рдХрдорд╛рдВрдб рдХреЛ рдЪрд▓рд╛рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

@bot.on_message(filters.group & filters.command("dice"))
async def dice_command(client, message):
    await client.send_dice(message.chat.id)

# --- New Features from Step 7, 8 & 9 ---
@bot.on_message(filters.group & filters.command("tts"))
async def tts_command(client, message):
    text = " ".join(message.command[1:])
    if not text:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рдХреЛрдИ рдЯреЗрдХреНрд╕реНрдЯ рджреЗрдВред\nрд╕рд╣реА рдЗрд╕реНрддреЗрдорд╛рд▓: `/tts рдирдорд╕реНрддреЗ, рдЖрдк рдХреИрд╕реЗ рд╣реИрдВ?`")
    
    try:
        tts = gTTS(text=text, lang='hi', slow=False)
        tts.save("tts.mp3")
        await client.send_audio(chat_id=message.chat.id, audio="tts.mp3", caption=f"рдЯреЗрдХреНрд╕реНрдЯ-рдЯреВ-рд╕реНрдкреАрдЪ рджреНрд╡рд╛рд░рд╛ рднреЗрдЬрд╛ рдЧрдпрд╛:\n`{text}`")
        os.remove("tts.mp3")
    except Exception as e:
        await message.reply(f"тЭМ рдСрдбрд┐рдпреЛ рдмрдирд╛рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

@bot.on_message(filters.group & filters.command("faq"))
async def faq_command(_, message):
    args = message.text.split()
    if len(args) < 2:
        faq_list = ", ".join(FAQ_DATA.keys())
        await message.reply(f"тЭМ рдХреГрдкрдпрд╛ рдПрдХ FAQ рдЪреБрдиреЗрдВред\nрдЙрдкрд▓рдмреНрдз FAQ: `{faq_list}`\nрд╕рд╣реА рдЗрд╕реНрддреЗрдорд╛рд▓: `/faq rules`")
        return
    
    query = args[1].lower()
    if query in FAQ_DATA:
        await message.reply(FAQ_DATA[query])
    else:
        await message.reply(f"тЭМ `{query}` рдХреЗ рд▓рд┐рдП рдХреЛрдИ FAQ рдирд╣реАрдВ рдорд┐рд▓рд╛ред")

# --- New Features from Step 10, 11 & 12 ---
@bot.on_message(filters.group & ~filters.via_bot)
async def update_stats(_, message):
    if not message.from_user:
        return
    user_id = message.from_user.id
    if user_id in user_stats:
        user_stats[user_id]['messages'] += 1
    else:
        user_stats[user_id] = {'messages': 1, 'name': message.from_user.first_name}

@bot.on_message(filters.group & filters.command("stats"))
async def stats_command(_, message):
    sorted_stats = sorted(user_stats.items(), key=lambda item: item[1]['messages'], reverse=True)
    
    stats_text = "ЁЯУК **Group Analytics: Top 5 Senders**\n\n"
    rank = 1
    for user_id, data in sorted_stats[:5]:
        stats_text += f"{rank}. **{data['name']}**: {data['messages']} messages\n"
        rank += 1
    
    if not sorted_stats:
        stats_text = "тЭМ рдЕрднреА рддрдХ рдХреЛрдИ рдбреЗрдЯрд╛ рдирд╣реАрдВ рд╣реИред рдХреБрдЫ рдореИрд╕реЗрдЬ рднреЗрдЬрдиреЗ рдХреЗ рдмрд╛рдж рдлрд┐рд░ рд╕реЗ рдХреЛрд╢рд┐рд╢ рдХрд░реЗрдВред"

    await message.reply(stats_text)

@bot.on_message(filters.group & filters.command("say"))
async def say_command(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗред")
    
    text = message.text.split(" ", 1)
    if len(text) < 2:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рдореБрдЭреЗ рдХреБрдЫ рдмреЛрд▓рдиреЗ рдХреЗ рд▓рд┐рдП рджреЗрдВред\nрд╕рд╣реА рдЗрд╕реНрддреЗрдорд╛рд▓: `/say рдЖрдкрдХрд╛ рдореИрд╕реЗрдЬ`")
    
    await message.delete()
    await client.send_message(message.chat.id, text[1])

# --- RSS Feed Check on a timer ---
async def check_rss_feed_periodically():
    global last_rss_entry_link
    while True:
        try:
            feed = feedparser.parse(RSS_FEED_URL)
            if not feed.entries:
                print("RSS feed has no entries.")
            else:
                new_entries = []
                for entry in reversed(feed.entries):
                    if entry.link == last_rss_entry_link:
                        break
                    new_entries.append(entry)
                
                if new_entries:
                    for entry in new_entries:
                        video_title = entry.title
                        video_link = entry.link
                        message_text = f"ЁЯУв **New YouTube Video!**\n\n**{video_title}**\n{video_link}"
                        await bot.send_message(RSS_CHANNEL_ID, message_text)
                    last_rss_entry_link = new_entries[-1].link
        except Exception as e:
            print(f"Error checking RSS feed: {e}")
        
        await asyncio.sleep(3600) # Check every 1 hour

@bot.on_message(filters.group & filters.command("start_rss"))
async def start_rss_command(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗред")
    
    if not RSS_CHANNEL_ID:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рдЕрдкрдиреА `.env` реЮрд╛рдЗрд▓ рдореЗрдВ `RSS_CHANNEL_ID` рдЬреЛрдбрд╝реЗрдВред")

    asyncio.create_task(check_rss_feed_periodically())
    await message.reply("тЬЕ RSS реЮреАрдб рдЪреЗрдХрд░ рд╢реБрд░реВ рд╣реЛ рдЧрдпрд╛ рд╣реИред")

# --- New Features from Step 14, 15, 16 & 17 ---

# Step 14: Backup & Persistence
@bot.on_message(filters.command("backup") & filters.user(OWNER_ID))
async def backup_settings(_, message):
    try:
        backup_data = {
            "faq_data": FAQ_DATA,
            "user_stats": user_stats,
            "premium_users": list(premium_users),
            "warn_counts": warn_counts,
            "scheduled_messages": scheduled_messages,
            "user_reputation": user_reputation
        }
        with open("bot_backup.json", "w") as f:
            json.dump(backup_data, f, indent=4)
        await message.reply_document(document="bot_backup.json", caption="тЬЕ рдмреЙрдЯ рд╕реЗрдЯрд┐рдВрдЧреНрд╕ рдХрд╛ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдмреИрдХрдЕрдк рд▓рд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
    except Exception as e:
        await message.reply(f"тЭМ рдмреИрдХрдЕрдк рд▓реЗрдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

@bot.on_message(filters.command("restore") & filters.user(OWNER_ID))
async def restore_settings(_, message):
    if not message.reply_to_message or not message.reply_to_message.document:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рдмреИрдХрдЕрдк реЮрд╛рдЗрд▓ рдкрд░ рд░рд┐рдкреНрд▓рд╛рдИ рдХрд░реЗрдВред")
    
    try:
        file_path = await message.reply_to_message.download()
        with open(file_path, "r") as f:
            restored_data = json.load(f)
        
        FAQ_DATA.clear()
        FAQ_DATA.update(restored_data.get("faq_data", {}))
        user_stats.clear()
        user_stats.update(restored_data.get("user_stats", {}))
        premium_users.clear()
        premium_users.update(set(restored_data.get("premium_users", [])))
        warn_counts.clear()
        warn_counts.update(restored_data.get("warn_counts", {}))
        scheduled_messages.clear()
        scheduled_messages.extend(restored_data.get("scheduled_messages", []))
        user_reputation.clear()
        user_reputation.update(restored_data.get("user_reputation", {}))

        await message.reply("тЬЕ рдмреЙрдЯ рд╕реЗрдЯрд┐рдВрдЧреНрд╕ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рд░рд┐рд╕реНрдЯреЛрд░ рд╣реЛ рдЧрдИ рд╣реИрдВред")
    except Exception as e:
        await message.reply(f"тЭМ реЮрд╛рдЗрд▓ рд░рд┐рд╕реНрдЯреЛрд░ рдХрд░рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

# Step 15: Privacy & Compliance
@bot.on_message(filters.command("mydata"))
async def my_data_command(_, message):
    user_id = message.from_user.id
    if user_id in user_stats:
        await message.reply(f"ЁЯУК рдЖрдкрдХреЗ рдбреЗрдЯрд╛ рдХреЗ рдЕрдиреБрд╕рд╛рд░, рдЖрдкрдиреЗ рдЕрднреА рддрдХ {user_stats[user_id]['messages']} рдореИрд╕реЗрдЬ рднреЗрдЬреЗ рд╣реИрдВред рдпрджрд┐ рдЖрдк рдЪрд╛рд╣рддреЗ рд╣реИрдВ рдХрд┐ рдпрд╣ рдбреЗрдЯрд╛ рдбрд┐рд▓реАрдЯ рдХрд░ рджрд┐рдпрд╛ рдЬрд╛рдП, рддреЛ `/deletedata` рдХрд╛ рдкреНрд░рдпреЛрдЧ рдХрд░реЗрдВред")
    else:
        await message.reply("тЭМ рдЖрдкрдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рдХреЛрдИ рдбреЗрдЯрд╛ рд╕рдВрдЧреНрд░рд╣реАрдд рдирд╣реАрдВ рд╣реИред")

@bot.on_message(filters.command("deletedata"))
async def delete_my_data_command(_, message):
    user_id = message.from_user.id
    if user_id in user_stats:
        del user_stats[user_id]
        await message.reply("тЬЕ рдЖрдкрдХрд╛ рдбреЗрдЯрд╛ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдбрд┐рд▓реАрдЯ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
    else:
        await message.reply("тЭМ рдЖрдкрдХрд╛ рдбреЗрдЯрд╛ рдкрд╣рд▓реЗ рд╕реЗ рд╣реА рдбрд┐рд▓реАрдЯреЗрдб рд╣реИред")

# Step 16: Monetization
@bot.on_message(filters.command("premium"))
async def premium_command(_, message):
    if message.from_user.id in premium_users:
        await message.reply("тЬЕ рдЖрдк рдкрд╣рд▓реЗ рд╕реЗ рд╣реА рдкреНрд░реАрдорд┐рдпрдо рд╕рджрд╕реНрдп рд╣реИрдВред")
    else:
        await message.reply("тЬи **рдкреНрд░реАрдорд┐рдпрдо рд╕рджрд╕реНрдпрддрд╛ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ!**\n\nрдкреНрд░реАрдорд┐рдпрдо рд╕реБрд╡рд┐рдзрд╛рдУрдВ рдХреЛ рдЕрдирд▓реЙрдХ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП [рдпрд╣рд╛рдБ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВ](https://example.com/premium)ред\n\nрдЙрджрд╛рд╣рд░рдг рдХреЗ рд▓рд┐рдП: рд╡рд┐рд╢реЗрд╖ рдЯреИрдЧ, рддреЗрдЬрд╝ AI рд░рд┐рд╕реНрдкрд╛рдВрд╕, рдФрд░ рдмрд╣реБрдд рдХреБрдЫ!")

@bot.on_message(filters.command("add_premium") & filters.user(OWNER_ID))
async def add_premium(_, message):
    parts = message.text.split()
    if len(parts) < 2:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рдпреВреЫрд░ ID рджреЗрдВред")
    
    try:
        user_id = int(parts[1])
        premium_users.add(user_id)
        await message.reply(f"тЬЕ рдпреВреЫрд░ `{user_id}` рдХреЛ рдкреНрд░реАрдорд┐рдпрдо рдореЗрдВ рдЬреЛрдбрд╝рд╛ рдЧрдпрд╛ред")
    except (IndexError, ValueError):
        await message.reply("тЭМ рдХреГрдкрдпрд╛ рдПрдХ рдорд╛рдиреНрдп рдпреВреЫрд░ ID рджреЗрдВред")

# Step 17: Cross-Group Bridging
@bot.on_message(filters.group & filters.command("forward_message"))
async def forward_to_other_group(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗред")

    parts = message.text.split()
    if len(parts) < 2:
        return await message.reply("тЭМ рд╕рд╣реА рдЗрд╕реНрддреЗрдорд╛рд▓: `/forward_message <group_id or username> <reply_to_message>`")

    target_chat = parts[1]
    if not message.reply_to_message:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рдЙрд╕ рдореИрд╕реЗрдЬ рдкрд░ рд░рд┐рдкреНрд▓рд╛рдИ рдХрд░реЗрдВ рдЬрд┐рд╕реЗ рдЖрдк рдлреЙрд░рд╡рд░реНрдб рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВред")
    
    try:
        await message.reply_to_message.forward(target_chat)
        await message.reply("тЬЕ рдореИрд╕реЗрдЬ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдлреЙрд░рд╡рд░реНрдб рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
    except Exception as e:
        await message.reply(f"тЭМ рдореИрд╕реЗрдЬ рдлреЙрд░рд╡рд░реНрдб рдХрд░рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

# --- New Features: Warning System & Scheduled Messages ---

@bot.on_message(filters.group & filters.command("warn"))
async def warn_user_command(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗред")

    target_user = await extract_target_user(message)
    if not target_user:
        return

    reason = "No reason provided."
    if len(message.command) > 1:
        reason = " ".join(message.command[1:])

    if target_user.id not in warn_counts:
        warn_counts[target_user.id] = 0
    
    warn_counts[target_user.id] += 1
    
    if warn_counts[target_user.id] >= 3:
        try:
            await client.ban_chat_member(message.chat.id, target_user.id)
            await message.reply(f"тЪая╕П **{target_user.first_name}** рдХреЛ 3 рдЪреЗрддрд╛рд╡рдирд┐рдпреЛрдВ рдХреЗ рдмрд╛рдж рдмреИрди рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред")
            await log_admin_action("Ban after 3 warns", message.from_user.first_name, target_user.first_name)
            del warn_counts[target_user.id]
        except Exception as e:
            await message.reply(f"тЭМ рдпреВреЫрд░ рдХреЛ рдмреИрди рдХрд░рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")
    else:
        await message.reply(f"тЪая╕П **{target_user.first_name}** рдХреЛ рдЪреЗрддрд╛рд╡рдиреА рджреА рдЧрдИ рд╣реИред\n**рдХрд╛рд░рдг:** {reason}\n**рдХреБрд▓ рдЪреЗрддрд╛рд╡рдиреА:** {warn_counts[target_user.id]}/3")
        await log_admin_action("Warn", message.from_user.first_name, target_user.first_name)

@bot.on_message(filters.group & filters.command("resetwarns"))
async def reset_warns_command(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗред")
    
    target_user = await extract_target_user(message)
    if not target_user:
        return
    
    if target_user.id in warn_counts:
        del warn_counts[target_user.id]
        await message.reply("тЬЕ рдпреВреЫрд░ рдХреА рдЪреЗрддрд╛рд╡рдирд┐рдпрд╛рдБ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рд░реАрд╕реЗрдЯ рдХрд░ рджреА рдЧрдИ рд╣реИрдВред")
    else:
        await message.reply("тЭМ рдЗрд╕ рдпреВреЫрд░ рдХреЗ рдкрд╛рд╕ рдХреЛрдИ рдЪреЗрддрд╛рд╡рдиреА рдирд╣реАрдВ рд╣реИред")

@bot.on_message(filters.group & filters.command("schedule"))
async def schedule_message_command(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗред")
        
    parts = message.text.split(" ", 2)
    if len(parts) < 3:
        return await message.reply("тЭМ рд╕рд╣реА рдЗрд╕реНрддреЗрдорд╛рд▓: `/schedule <рд╕рдордп> <рдореИрд╕реЗрдЬ>`\nрдЙрджрд╛рд╣рд░рдг: `/schedule 10m Hello everyone!`")
        
    time_str = parts[1]
    message_text = parts[2]
    
    try:
        time_value = int(time_str[:-1])
        time_unit = time_str[-1].lower()
    except (IndexError, ValueError):
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рд╕рдордп рдФрд░ рдореИрд╕реЗрдЬ рд╕рд╣реА реЮреЙрд░реНрдореЗрдЯ рдореЗрдВ рджреЗрдВред")

    if time_unit == 's':
        delay = time_value
    elif time_unit == 'm':
        delay = time_value * 60
    elif time_unit == 'h':
        delay = time_value * 3600
    else:
        return await message.reply("тЭМ рдЕрдорд╛рдиреНрдп рд╕рдордп рдЗрдХрд╛рдИред рдХреЗрд╡рд▓ 's' (рд╕реЗрдХрдВрдб), 'm' (рдорд┐рдирдЯ), 'h' (рдШрдВрдЯреЗ) рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред")

    send_time = datetime.now(timezone.utc) + timedelta(seconds=delay)
    
    scheduled_messages.append({
        "chat_id": message.chat.id,
        "text": message_text,
        "send_time": send_time.isoformat()
    })
    
    await message.reply(f"тЬЕ рдЖрдкрдХрд╛ рдореИрд╕реЗрдЬ **{send_time.strftime('%H:%M:%S')}** рдкрд░ рднреЗрдЬрдиреЗ рдХреЗ рд▓рд┐рдП рд╢реЗрдбреНрдпреВрд▓ рд╣реЛ рдЧрдпрд╛ рд╣реИред")

# Background task to send scheduled messages
async def send_scheduled_messages():
    while True:
        messages_to_send = []
        now = datetime.now(timezone.utc)
        
        for msg in scheduled_messages:
            send_time = datetime.fromisoformat(msg["send_time"])
            if now >= send_time:
                messages_to_send.append(msg)
        
        for msg in messages_to_send:
            try:
                await bot.send_message(msg["chat_id"], msg["text"])
                scheduled_messages.remove(msg)
            except Exception as e:
                print(f"Failed to send scheduled message: {e}")
                scheduled_messages.remove(msg)
        
        await asyncio.sleep(5)

# --- NEW: AI-Powered Chat (Simple, Rule-based) ---
@bot.on_message(filters.group & filters.text & filters.regex(r"(?i)^(hello bot|namaste bot|hi bot)$"))
async def ai_hello(_, message):
    await message.reply("рдирдорд╕реНрддреЗ! рдореИрдВ рдЖрдкрдХреЗ рд╕рд╡рд╛рд▓ рдХрд╛ рдЬрд╡рд╛рдм рджреЗрдиреЗ рдХреЗ рд▓рд┐рдП рдпрд╣рд╛рдБ рд╣реВрдБред рдЖрдк рдореБрдЭрд╕реЗ рдХреБрдЫ рднреА рдкреВрдЫ рд╕рдХрддреЗ рд╣реИрдВред")

@bot.on_message(filters.group & filters.text & filters.regex(r"(?i)^(tum kon ho|what are you|who are you)$"))
async def ai_who_are_you(_, message):
    await message.reply(f"рдореИрдВ **{BOT_NAME}** рд╣реВрдБ, рдЖрдкрдХреЗ рдЧреНрд░реБрдк рдХреЛ рдореИрдиреЗрдЬ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдПрдХ рдПрдбрд╡рд╛рдВрд╕ рдмреЙрдЯред")

# --- NEW: Reputation System ---
@bot.on_message(filters.group & filters.command("rep"))
async def give_rep_command(_, message):
    if not message.reply_to_message:
        return await message.reply("тЭМ рдХрд┐рд╕реА рдпреВреЫрд░ рдХреЛ +rep рджреЗрдиреЗ рдХреЗ рд▓рд┐рдП рдЙрд╕рдХреЗ рдореИрд╕реЗрдЬ рдкрд░ рд░рд┐рдкреНрд▓рд╛рдИ рдХрд░реЗрдВред")
    
    target_user = message.reply_to_message.from_user
    sender_user = message.from_user

    if target_user.id == sender_user.id:
        return await message.reply("тЭМ рдЖрдк рдЦреБрдж рдХреЛ +rep рдирд╣реАрдВ рджреЗ рд╕рдХрддреЗред")

    if target_user.id not in user_reputation:
        user_reputation[target_user.id] = 0
    
    user_reputation[target_user.id] += 1
    
    await message.reply(f"тЬЕ **{target_user.first_name}** рдХреЛ рдПрдХ рдкреНрд░рддрд┐рд╖реНрдард╛ рдЕрдВрдХ (+1 rep) рдорд┐рд▓рд╛ред рдЕрдм рдЙрдирдХреЗ рдкрд╛рд╕ {user_reputation[target_user.id]} рдЕрдВрдХ рд╣реИрдВред")

@bot.on_message(filters.group & filters.command("reps"))
async def show_reps_command(_, message):
    sorted_reps = sorted(user_reputation.items(), key=lambda item: item[1], reverse=True)
    
    reps_text = "тЬи **Group Reputation Leaderboard**\n\n"
    if not sorted_reps:
        reps_text = "тЭМ рдЕрднреА рддрдХ рдХреЛрдИ рдкреНрд░рддрд┐рд╖реНрдард╛ рдЕрдВрдХ рдирд╣реАрдВ рд╣реИред"
    else:
        for user_id, rep_count in sorted_reps[:5]:
            try:
                user = await bot.get_users(user_id)
                reps_text += f"**{user.first_name}**: {rep_count} рдЕрдВрдХ\n"
            except:
                pass

    await message.reply(reps_text)

# --- NEW: Ticket System ---
@bot.on_message(filters.private & filters.command("ticket"))
async def ticket_command(_, message):
    ticket_text = message.text.split(" ", 1)
    if len(ticket_text) < 2:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рдЕрдкрдирд╛ рд╕рд╡рд╛рд▓ рд▓рд┐рдЦреЗрдВред\nрд╕рд╣реА рдЗрд╕реНрддреЗрдорд╛рд▓: `/ticket рдЖрдкрдХрд╛ рд╕рд╡рд╛рд▓`")

    user_name = message.from_user.first_name
    ticket_message = f"ЁЯЪи **рдирдпрд╛ рд╕рдкреЛрд░реНрдЯ рдЯрд┐рдХрдЯ!**\n\n**рднреЗрдЬрдиреЗ рд╡рд╛рд▓рд╛:** {user_name} (`{message.from_user.id}`)\n\n**рд╕рд╡рд╛рд▓:**\n`{ticket_text[1]}`"
    
    await bot.send_message(OWNER_ID, ticket_message)
    await message.reply("тЬЕ рдЖрдкрдХрд╛ рдЯрд┐рдХрдЯ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рднреЗрдЬ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред рдЬрд▓реНрдж рд╣реА рдЖрдкрд╕реЗ рд╕рдВрдкрд░реНрдХ рдХрд┐рдпрд╛ рдЬрд╛рдПрдЧрд╛ред")

# --- NEW: Voice to Text ---
@bot.on_message(filters.group & filters.command("vtt"))
async def voice_to_text_command(client, message):
    if not message.reply_to_message or not message.reply_to_message.voice:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рдПрдХ рд╡реЙрдЗрд╕ рдореИрд╕реЗрдЬ рдкрд░ рд░рд┐рдкреНрд▓рд╛рдИ рдХрд░реЗрдВред")

    try:
        await message.reply("ЁЯФД рдЯреНрд░рд╛рдВрд╕рдХреНрд░рд╛рдЗрдм рдХрд┐рдпрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИ... рдХреГрдкрдпрд╛ рдкреНрд░рддреАрдХреНрд╖рд╛ рдХрд░реЗрдВред")
        voice_file_path = await message.reply_to_message.download()

        audio = AudioSegment.from_ogg(voice_file_path)
        audio.export("voice.wav", format="wav")

        recognizer = sr.Recognizer()
        with sr.AudioFile("voice.wav") as source:
            audio_data = recognizer.record(source)
            text = recognizer.recognize_google(audio_data, language="hi-IN")
            await message.reply(f"ЁЯОд **рдЯреЗрдХреНрд╕реНрдЯ:** `{text}`")

    except sr.UnknownValueError:
        await message.reply("тЭМ рд╡реЙрдЗрд╕ рдХреЛ рдЯреЗрдХреНрд╕реНрдЯ рдореЗрдВ рдмрджрд▓ рдирд╣реАрдВ рд╕рдХрд╛ред рдХреГрдкрдпрд╛ рд╕реНрдкрд╖реНрдЯ рдмреЛрд▓реЗрдВред")
    except Exception as e:
        await message.reply(f"тЭМ рд╡реЙрдЗрд╕ рдХреЛ рдЯреЗрдХреНрд╕реНрдЯ рдореЗрдВ рдмрджрд▓рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")
    finally:
        if os.path.exists(voice_file_path):
            os.remove(voice_file_path)
        if os.path.exists("voice.wav"):
            os.remove("voice.wav")

# --- NEW: Admin Broadcast ---
@bot.on_message(filters.user(OWNER_ID) & filters.command("broadcast"))
async def broadcast_message_command(client, message):
    broadcast_text = message.text.split(" ", 1)
    if len(broadcast_text) < 2:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рд╡рд╣ рдореИрд╕реЗрдЬ рджреЗрдВ рдЬрд┐рд╕реЗ рдЖрдк рдмреНрд░реЙрдбрдХрд╛рд╕реНрдЯ рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВред")
    
    success_count = 0
    failure_count = 0
    
    async for dialog in client.get_dialogs():
        if dialog.chat.type in [ChatType.GROUP, ChatType.SUPERGROUP, ChatType.CHANNEL]:
            try:
                await client.send_message(dialog.chat.id, broadcast_text[1])
                success_count += 1
            except Exception:
                failure_count += 1
    
    await message.reply(f"тЬЕ рдореИрд╕реЗрдЬ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рднреЗрдЬрд╛ рдЧрдпрд╛ред\nрд╕рдлрд▓рддрд╛: {success_count}\nрд╡рд┐рдлрд▓рддрд╛: {failure_count}")

# --- NEW: Tag All ---
@bot.on_message(filters.group & filters.command("tagall"))
async def tag_all_command(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗред")

    members = []
    async for member in client.get_chat_members(message.chat.id):
        if not member.user.is_bot:
            members.append(f"[{member.user.first_name}](tg://user?id={member.user.id})")
    
    if not members:
        return await message.reply("тЭМ рдЗрд╕ рдЧреНрд░реБрдк рдореЗрдВ рдЯреИрдЧ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдХреЛрдИ рд╕рджрд╕реНрдп рдирд╣реАрдВ рд╣реИред")

    text = " ".join(members)
    await message.reply(f"ЁЯСе рд╕рднреА рдХреЛ рдЯреИрдЧ рдХрд┐рдпрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИ:\n\n{text}", disable_web_page_preview=True)

# --- NEW: Auto-Delete Message ---
@bot.on_message(filters.group & filters.command("autodelete"))
async def autodelete_message(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗред")
    
    parts = message.text.split()
    if len(parts) < 2 or not parts[1].endswith(('m', 'h', 's')):
        return await message.reply("тЭМ рд╕рд╣реА рдЗрд╕реНрддреЗрдорд╛рд▓: `/autodelete <time>`")
        
    time_str = parts[1]
    
    try:
        time_value = int(time_str[:-1])
        time_unit = time_str[-1].lower()
    except (IndexError, ValueError):
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рд╕рдордп рд╕рд╣реА реЮреЙрд░реНрдореЗрдЯ рдореЗрдВ рджреЗрдВред")
        
    if time_unit == 's':
        delay = time_value
    elif time_unit == 'm':
        delay = time_value * 60
    elif time_unit == 'h':
        delay = time_value * 3600
    else:
        return await message.reply("тЭМ рдЕрдорд╛рдиреНрдп рд╕рдордп рдЗрдХрд╛рдИред рдХреЗрд╡рд▓ 's' (рд╕реЗрдХрдВрдб), 'm' (рдорд┐рдирдЯ), 'h' (рдШрдВрдЯреЗ) рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред")
    
    if delay > 3600:
        return await message.reply("тЭМ рдореИрдВ 1 рдШрдВрдЯреЗ рд╕реЗ реЫреНрдпрд╛рджрд╛ рдХрд╛ рдСрдЯреЛ-рдбрд┐рд▓реАрдЯ рдЯрд╛рдЗрдорд░ рдирд╣реАрдВ рд▓рдЧрд╛ рд╕рдХрддрд╛ред")

    sent_message = await message.reply(f"тЬЕ рдпрд╣ рдореИрд╕реЗрдЬ {time_value}{time_unit} рдХреЗ рдмрд╛рдж рдЕрдкрдиреЗ рдЖрдк рдбрд┐рд▓реАрдЯ рд╣реЛ рдЬрд╛рдПрдЧрд╛ред")
    auto_delete_timers[sent_message.chat.id] = {
        "message_id": sent_message.id,
        "delete_time": datetime.now(timezone.utc) + timedelta(seconds=delay)
    }

async def check_auto_delete():
    while True:
        now = datetime.now(timezone.utc)
        messages_to_delete = []
        for chat_id, data in auto_delete_timers.items():
            if now >= data["delete_time"]:
                messages_to_delete.append((chat_id, data["message_id"]))
        
        for chat_id, message_id in messages_to_delete:
            try:
                await bot.delete_messages(chat_id, message_id)
                del auto_delete_timers[chat_id]
            except Exception as e:
                print(f"Failed to delete message: {e}")
        
        await asyncio.sleep(5)

# --- NEW: Advanced Polling ---
@bot.on_message(filters.group & filters.command("stoppoll"))
async def stop_poll_command(client, message):
    if not await deterministic_privilege_validator(message):
        return await message.reply("тЭМ рдЖрдк рдпрд╣ рдХрдорд╛рдВрдб рдЗрд╕реНрддреЗрдорд╛рд▓ рдирд╣реАрдВ рдХрд░ рд╕рдХрддреЗред")
    
    if not message.reply_to_message or not message.reply_to_message.poll:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рдЙрд╕ рдкреЛрд▓ рдкрд░ рд░рд┐рдкреНрд▓рд╛рдИ рдХрд░реЗрдВ рдЬрд┐рд╕реЗ рдЖрдк рдмрдВрдж рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВред")
    
    try:
        await client.stop_poll(message.chat.id, message.reply_to_message.id)
    except Exception as e:
        await message.reply(f"тЭМ рдкреЛрд▓ рдХреЛ рдмрдВрдж рдХрд░рдиреЗ рдореЗрдВ рдПрдХ рд╕рдорд╕реНрдпрд╛ рдЖрдИред\nError: {e}")

# --- NEW: User Info ---
@bot.on_message(filters.group & filters.command("info"))
async def user_info_command(_, message):
    if not message.reply_to_message:
        return await message.reply("тЭМ рдХреГрдкрдпрд╛ рдПрдХ рдпреВреЫрд░ рдХреЗ рдореИрд╕реЗрдЬ рдкрд░ рд░рд┐рдкреНрд▓рд╛рдИ рдХрд░реЗрдВред")
        
    user = message.reply_to_message.from_user
    
    user_info = f"ЁЯСд **рдпреВреЫрд░ рдЬрд╛рдирдХрд╛рд░реА**\n\n"
    user_info += f"**рдирд╛рдо:** {user.first_name}\n"
    if user.username:
        user_info += f"**рдпреВреЫрд░рдиреЗрдо:** @{user.username}\n"
    user_info += f"**рдЖрдИрдбреА:** `{user.id}`\n"
    user_info += f"**рдкрд░реНрдорд▓рд┐рдВрдХ:** [Link](tg://user?id={user.id})\n"
    
    if user.id in user_stats:
        user_info += f"**рдХреБрд▓ рдореИрд╕реЗрдЬ:** {user_stats[user.id]['messages']}\n"
    if user.id in user_reputation:
        user_info += f"**рдкреНрд░рддрд┐рд╖реНрдард╛:** {user_reputation[user.id]} рдЕрдВрдХ\n"
    if user.id in warn_counts:
        user_info += f"**рдЪреЗрддрд╛рд╡рдиреА:** {warn_counts[user.id]}/3\n"
    
    await message.reply(user_info, disable_web_page_preview=True)

# --- NEW: Chat Info ---
@bot.on_message(filters.group & filters.command("chatinfo"))
async def chat_info_command(client, message):
    chat = message.chat
    
    chat_info = f"тД╣я╕П **рдЧреНрд░реБрдк рдЬрд╛рдирдХрд╛рд░реА**\n\n"
    chat_info += f"**рдирд╛рдо:** {chat.title}\n"
    if chat.username:
        chat_info += f"**рдпреВреЫрд░рдиреЗрдо:** @{chat.username}\n"
    chat_info += f"**рдЖрдИрдбреА:** `{chat.id}`\n"
    
    try:
        member_count = await client.get_chat_members_count(chat.id)
        chat_info += f"**рд╕рджрд╕реНрдп:** {member_count}\n"
    except Exception as e:
        print(f"Failed to get member count: {e}")
        
    await message.reply(chat_info, disable_web_page_preview=True)


if __name__ == "__main__":
    print("Bot started. Press Ctrl+C to stop.")
    asyncio.get_event_loop().create_task(send_scheduled_messages())
    asyncio.get_event_loop().create_task(check_auto_delete())
    bot.run()
