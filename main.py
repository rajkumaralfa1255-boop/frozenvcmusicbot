import os
import re
import sys
import time
import json
import logging
import asyncio
import random
import requests
from pydub import AudioSegment
from datetime import datetime, timezone, timedelta
from dotenv import load_dotenv
from flask import Flask, request
from pyrogram import Client, filters, errors
from pyrogram.enums import ChatType, ChatMemberStatus, ParseMode
from pyrogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ChatPermissions,
    ChatMember,
)
from gtts import gTTS

# Load environment variables
load_dotenv()

API_ID = int(os.environ.get("API_ID"))
API_HASH = os.environ.get("API_HASH")
BOT_TOKEN = os.environ.get("BOT_TOKEN")
OWNER_ID = int(os.getenv("OWNER_ID", "5268762773"))
LOG_CHANNEL_ID = int(os.getenv("LOG_CHANNEL_ID", None))
OPENWEATHER_API_KEY = os.environ.get("OPENWEATHER_API_KEY", None)

# Initialize the bot client
session_name = os.environ.get("SESSION_NAME", "help_bot")
bot = Client(session_name, bot_token=BOT_TOKEN, api_id=API_ID, api_hash=API_HASH)

# Define bot name for dynamic use
BOT_NAME = os.environ.get("BOT_NAME", "Frozen Help Bot")
BOT_LINK = os.environ.get("BOT_LINK", f"https://t.me/{bot.get_me().username}")

# In-memory storage for various data
user_stats = {}
premium_users = set()
FAQ_DATA = {
    "rules": "‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§®‡§ø‡§Ø‡§Æ:\n1. ‡§ï‡•ã‡§à ‡§∏‡•ç‡§™‡•à‡§Æ‡§ø‡§Ç‡§ó ‡§®‡§π‡•Ä‡§Ç\n2. ‡§ï‡•ã‡§à ‡§ó‡§æ‡§≤‡•Ä-‡§ó‡§≤‡•å‡§ú ‡§®‡§π‡•Ä‡§Ç\n3. ‡§ï‡•á‡§µ‡§≤ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§∏‡§Ç‡§¨‡§Ç‡§ß‡§ø‡§§ ‡§¨‡§æ‡§§‡•á‡§Ç‡•§",
    "help": "‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§¶‡§¶ ‡§ï‡•à‡§∏‡•á ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Å? `/help` ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è ‡§¨‡§ü‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§",
    "contact": "‡§è‡§°‡§Æ‡§ø‡§® ‡§∏‡•á ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è @Frozensupport1 ‡§™‡§∞ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§",
}
warn_counts = {}
user_message_timestamps = {}
scheduled_messages = []
user_reputation = {}
auto_delete_timers = {}
notes_data = {}
gban_list = set()
custom_welcome_messages = {}
link_whitelist = set()
restricted_file_types = set()

# Load data from file if it exists
def load_data():
    global notes_data, gban_list
    try:
        with open("bot_data.json", "r") as f:
            data = json.load(f)
            notes_data = data.get("notes_data", {})
            gban_list.update(data.get("gban_list", []))
            print("Data loaded successfully.")
    except (FileNotFoundError, json.JSONDecodeError):
        print("No existing data file found or file is empty.")

# Save data to file
def save_data():
    data = {
        "notes_data": notes_data,
        "gban_list": list(gban_list)
    }
    with open("bot_data.json", "w") as f:
        json.dump(data, f, indent=4)
    print("Data saved successfully.")

# Auto-mute on low messages settings
LOW_MSG_MUTE_THRESHOLD = 5
LOW_MSG_MUTE_TIME = 300 # 5 minutes

# Pre-defined game data
TRUTH_QUESTIONS = ["‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™‡§®‡•á ‡§ï‡§≠‡•Ä ‡§Ö‡§™‡§®‡•á ‡§¶‡•ã‡§∏‡•ç‡§§ ‡§ï‡•ã ‡§ù‡•Ç‡§† ‡§¨‡•ã‡§≤‡§æ ‡§π‡•à?", "‡§Ü‡§™‡§ï‡•Ä ‡§∏‡§¨‡§∏‡•á ‡§Ö‡§ú‡•Ä‡§¨ ‡§Ü‡§¶‡§§ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?", "‡§Ü‡§™‡§ï‡•Ä ‡§∏‡§¨‡§∏‡•á ‡§¨‡§°‡§º‡•Ä ‡§°‡§∞ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?", "‡§Ü‡§™‡§®‡•á ‡§Ö‡§™‡§®‡•á ‡§ú‡•Ä‡§µ‡§® ‡§Æ‡•á‡§Ç ‡§∏‡§¨‡§∏‡•á ‡§Ö‡§ú‡•Ä‡§¨ ‡§ï‡§æ‡§Æ ‡§ï‡•ç‡§Ø‡§æ ‡§ï‡§ø‡§Ø‡§æ ‡§π‡•à?"]
DARE_CHALLENGES = ["‡§Ö‡§™‡§®‡•Ä ‡§™‡•ç‡§∞‡•ã‡§´‡§º‡§æ‡§á‡§≤ ‡§´‡§º‡•ã‡§ü‡•ã 1 ‡§ò‡§Ç‡§ü‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§¨‡§¶‡§≤‡•á‡§Ç‡•§", "‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§ú‡•ã‡§ï ‡§∏‡•Å‡§®‡§æ‡§è‡§Ç‡•§", "1 ‡§Æ‡§ø‡§®‡§ü ‡§§‡§ï ‡§Ö‡§™‡§®‡•Ä ‡§®‡§æ‡§ï ‡§™‡§∞ ‡§Ö‡§™‡§®‡•Ä ‡§â‡§Ç‡§ó‡§≤‡•Ä ‡§∞‡§ñ‡•á‡§Ç‡•§", "‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§Ö‡§ú‡•Ä‡§¨‡•ã‡§ó‡§∞‡•Ä‡§¨ ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§®‡§ø‡§ï‡§æ‡§≤‡•á‡§Ç‡•§"]
TRIVIA_QUESTIONS = {
    "‡§≠‡§æ‡§∞‡§§ ‡§ï‡•Ä ‡§∞‡§æ‡§ú‡§ß‡§æ‡§®‡•Ä ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?": "‡§¶‡§ø‡§≤‡•ç‡§≤‡•Ä",
    "‡§∏‡•Ç‡§∞‡•ç‡§Ø ‡§∏‡•á ‡§∏‡§¨‡§∏‡•á ‡§®‡§ø‡§ï‡§ü‡§§‡§Æ ‡§ó‡•ç‡§∞‡§π ‡§ï‡•å‡§® ‡§∏‡§æ ‡§π‡•à?": "‡§¨‡•Å‡§ß",
    "‡§∞‡§æ‡§∑‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Ø ‡§ó‡§æ‡§® ‡§ï‡§ø‡§∏‡§®‡•á ‡§≤‡§ø‡§ñ‡§æ ‡§•‡§æ?": "‡§∞‡§µ‡•Ä‡§Ç‡§¶‡•ç‡§∞‡§®‡§æ‡§• ‡§ü‡•à‡§ó‡•ã‡§∞",
    "‡§∏‡§¨‡§∏‡•á ‡§¨‡§°‡§º‡§æ ‡§Æ‡§π‡§æ‡§∏‡§æ‡§ó‡§∞ ‡§ï‡•å‡§® ‡§∏‡§æ ‡§π‡•à?": "‡§™‡•ç‡§∞‡§∂‡§æ‡§Ç‡§§ ‡§Æ‡§π‡§æ‡§∏‡§æ‡§ó‡§∞",
}
trivia_game = {}

# --- Helper functions ---
async def is_admin_or_owner(message: Message):
    if message.from_user.id == OWNER_ID:
        return True
    
    try:
        chat_member: ChatMember = await message._client.get_chat_member(
            chat_id=message.chat.id,
            user_id=message.from_user.id
        )
        return chat_member.status in [ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER]
    except Exception:
        return False

def to_bold_unicode(text: str) -> str:
    bold_text = ""
    for char in text:
        if 'A' <= char <= 'Z':
            bold_text += chr(ord('ùóî') + (ord(char) - ord('A')))
        elif 'a' <= char <= 'z':
            bold_text += chr(ord('ùóÆ') + (ord(char) - ord('a')))
        else:
            bold_text += char
    return bold_text

async def extract_target_user(message: Message):
    if message.reply_to_message:
        return message.reply_to_message.from_user
    
    parts = message.text.split()
    if len(parts) < 2:
        await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡§ø‡§∏‡•Ä ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§â‡§∏‡§ï‡§æ @username/user_id ‡§¶‡•á‡§Ç‡•§")
        return None

    target = parts[1]
    if target.startswith("@"):
        target = target[1:]
    try:
        user = await message._client.get_users(target)
        return user
    except Exception:
        await message.reply("‚ùå ‡§Ø‡§π ‡§Ø‡•Ç‡•õ‡§∞ ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ‡•§")
        return None

async def log_admin_action(action: str, admin: str, target: str):
    if LOG_CHANNEL_ID:
        log_message = f"üõ°Ô∏è **‡§è‡§°‡§Æ‡§ø‡§® ‡§≤‡•â‡§ó**\n\n**‡§ï‡§æ‡§∞‡•ç‡§Ø:** {action}\n**‡§è‡§°‡§Æ‡§ø‡§®:** {admin}\n**‡§≤‡§ï‡•ç‡§∑‡•ç‡§Ø:** {target}"
        try:
            await bot.send_message(LOG_CHANNEL_ID, log_message)
        except Exception as e:
            print(f"Failed to send log to channel: {e}")

# --- New Enhanced UI for Start/Help ---
@bot.on_message(filters.command(["start", "help"]))
async def start_and_help_handler(_, message):
    user_id = message.from_user.id
    raw_name = message.from_user.first_name or ""
    styled_name = to_bold_unicode(raw_name)

    caption = (
        f"üëã **‡§®‡§Æ‡§∏‡•ç‡§§‡•á {styled_name}!**\n\n"
        f"‡§Æ‡•à‡§Ç ‡§è‡§ï ‡§è‡§°‡§µ‡§æ‡§Ç‡§∏ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•à‡§®‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§Ö‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§π‡•Ç‡§Å‡•§\n"
        f"‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•ã ‡§∏‡§æ‡§´, ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§î‡§∞ ‡§µ‡•ç‡§Ø‡§µ‡§∏‡•ç‡§•‡§ø‡§§ ‡§∞‡§ñ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡§æ ‡§π‡•Ç‡§Å‡•§\n\n"
        f"‡§Æ‡•á‡§∞‡•á ‡§∏‡§≠‡•Ä ‡•û‡•Ä‡§ö‡§∞‡•ç‡§∏ ‡§ï‡•ã ‡§è‡§ï‡•ç‡§∏‡§™‡•ç‡§≤‡•ã‡§∞ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è **Help** ‡§¨‡§ü‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§\n\n"
        f"**Developer:** [Shubham](tg://user?id={OWNER_ID})"
    )
    buttons = [
        [
            InlineKeyboardButton("‚ûï ‡§Æ‡•Å‡§ù‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§ú‡•ã‡§°‡§º‡•á‡§Ç", url=f"https://t.me/{bot.get_me().username}?startgroup=true"),
            InlineKeyboardButton("üì¢ ‡§Ö‡§™‡§°‡•á‡§ü‡•ç‡§∏", url="https://t.me/vibeshiftbots")
        ],
        [
            InlineKeyboardButton("‚ùì Help", callback_data="show_help"),
            InlineKeyboardButton("üí¨ ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü", url="https://t.me/Frozensupport1")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(buttons)
    await message.reply_animation(
        animation="https://frozen-imageapi.lagendplayersyt.workers.dev/file/2e483e17-05cb-45e2-b166-1ea476ce9521.mp4",
        caption=caption,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )

@bot.on_callback_query(filters.regex("show_help"))
async def show_help_callback(_, callback_query):
    text = "**üìö ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏ ‡§ï‡§æ ‡§Æ‡•á‡§®‡•Ç**\n\n‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è ‡§¨‡§ü‡§®‡•ç‡§∏ ‡§∏‡•á ‡§Ü‡§™ ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏ ‡§ï‡•ã ‡§ï‡•à‡§ü‡•á‡§ó‡§∞‡•Ä ‡§ï‡•á ‡§Ö‡§®‡•Å‡§∏‡§æ‡§∞ ‡§¶‡•á‡§ñ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§"
    buttons = [
        [InlineKeyboardButton("üõ°Ô∏è ‡§è‡§°‡§Æ‡§ø‡§® ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏", callback_data="help_admin"),
         InlineKeyboardButton("üöÄ ‡§Ø‡•Ç‡§ü‡§ø‡§≤‡§ø‡§ü‡•Ä ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏", callback_data="help_utility")],
        [InlineKeyboardButton("üòÑ ‡§Æ‡§®‡•ã‡§∞‡§Ç‡§ú‡§® ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏", callback_data="help_fun"),
         InlineKeyboardButton("‚ÑπÔ∏è ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏", callback_data="help_info")],
        [InlineKeyboardButton("üè† ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§™‡•á‡§ú ‡§™‡§∞ ‡§µ‡§æ‡§™‡§∏", callback_data="go_back")]
    ]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("help_admin"))
async def help_admin_callback(_, callback_query):
    text = (
        "üõ°Ô∏è **‡§è‡§°‡§Æ‡§ø‡§® ‡§î‡§∞ ‡§Æ‡•â‡§°‡§∞‡•á‡§∏‡§® ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏**\n\n"
        "`/mute <reply> or <username>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§π‡§Æ‡•á‡§∂‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/tmute <reply> <time>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§ï‡•Å‡§õ ‡§¶‡•á‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/unmute <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§Ö‡§®‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/ban <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§¨‡•à‡§® ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/unban <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§Ö‡§®‡§¨‡•à‡§® ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/kick <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§ï‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/warn <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡•Ä ‡§¶‡•á‡§Ç (3 ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•á ‡§¨‡§æ‡§¶ ‡§¨‡•à‡§®)‡•§\n"
        "`/resetwarns <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•Ä ‡§ö‡•á‡§§‡§æ‡§µ‡§®‡§ø‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§∞‡•Ä‡§∏‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/del`: ‡§Æ‡•à‡§∏‡•á‡§ú ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/setwelcome`: ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§µ‡•á‡§≤‡§ï‡§Æ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§∏‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/autodelete <time>`: ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡•ã ‡§ë‡§ü‡•ã-‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§"
    )
    buttons = [[InlineKeyboardButton("üîô ‡§µ‡§æ‡§™‡§∏", callback_data="show_help")]]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("help_utility"))
async def help_utility_callback(_, callback_query):
    text = (
        "üöÄ **‡§Ø‡•Ç‡§ü‡§ø‡§≤‡§ø‡§ü‡•Ä ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏**\n\n"
        "`/tts <text>`: ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§ï‡•ã ‡§ë‡§°‡§ø‡§Ø‡•ã ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤‡•á‡§Ç‡•§\n"
        "`/vtt`: ‡§µ‡•â‡§á‡§∏ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡•ã ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤‡•á‡§Ç‡•§\n"
        "`/schedule <time> <text>`: ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡•ã ‡§∂‡•á‡§°‡•ç‡§Ø‡•Ç‡§≤ ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/broadcast <message>`: ‡§∏‡§≠‡•Ä ‡§ó‡•ç‡§∞‡•Å‡§™‡•ç‡§∏ ‡§Æ‡•á‡§Ç ‡§¨‡•ç‡§∞‡•â‡§°‡§ï‡§æ‡§∏‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç (‡§ï‡•á‡§µ‡§≤ ‡§Æ‡§æ‡§≤‡§ø‡§ï)‡•§\n"
        "`/gban <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§¨‡•â‡§ü ‡§ï‡•á ‡§∏‡§≠‡•Ä ‡§ó‡•ç‡§∞‡•Å‡§™‡•ç‡§∏ ‡§∏‡•á ‡§¨‡•à‡§® ‡§ï‡§∞‡•á‡§Ç (‡§ï‡•á‡§µ‡§≤ ‡§Æ‡§æ‡§≤‡§ø‡§ï)‡•§\n"
        "`/ungban <reply>`: ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•ã ‡§¨‡•â‡§ü ‡§ï‡•á ‡§∏‡§≠‡•Ä ‡§ó‡•ç‡§∞‡•Å‡§™‡•ç‡§∏ ‡§∏‡•á ‡§Ö‡§®‡§¨‡•à‡§® ‡§ï‡§∞‡•á‡§Ç (‡§ï‡•á‡§µ‡§≤ ‡§Æ‡§æ‡§≤‡§ø‡§ï)‡•§"
    )
    buttons = [[InlineKeyboardButton("üîô ‡§µ‡§æ‡§™‡§∏", callback_data="show_help")]]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("help_fun"))
async def help_fun_callback(_, callback_query):
    text = (
        "üòÑ **‡§Æ‡§®‡•ã‡§∞‡§Ç‡§ú‡§® ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏**\n\n"
        "`/poll <question> <options>`: ‡§è‡§ï ‡§™‡•ã‡§≤ ‡§¨‡§®‡§æ‡§è‡§Ç‡•§\n"
        "`/couple`: ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡§æ 'Couple of the Day' ‡§ö‡•Å‡§®‡•á‡§Ç‡•§\n"
        "`/dice`: ‡§è‡§ï ‡§°‡§æ‡§á‡§∏ ‡§∞‡•ã‡§≤ ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/rep <reply>`: ‡§ï‡§ø‡§∏‡•Ä ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•Ä ‡§™‡•ç‡§∞‡§§‡§ø‡§∑‡•ç‡§†‡§æ ‡§¨‡§¢‡§º‡§æ‡§è‡§Ç‡•§\n"
        "`/reps`: ‡§∏‡§¨‡§∏‡•á ‡•õ‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§™‡•ç‡§∞‡§§‡§ø‡§∑‡•ç‡§†‡§æ ‡§µ‡§æ‡§≤‡•á ‡§∏‡§¶‡§∏‡•ç‡§Ø‡•ã‡§Ç ‡§ï‡•ã ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§\n"
        "`/quote`: ‡§è‡§ï ‡§™‡•ç‡§∞‡•á‡§∞‡§£‡§æ‡§¶‡§æ‡§Ø‡§ï ‡§ï‡•ã‡§ü ‡§™‡§æ‡§è‡§Ç‡•§"
    )
    buttons = [[InlineKeyboardButton("üîô ‡§µ‡§æ‡§™‡§∏", callback_data="show_help")]]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("help_info"))
async def help_info_callback(_, callback_query):
    text = (
        "‚ÑπÔ∏è **‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏**\n\n"
        "`/stats`: ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§ü‡•â‡§™ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§∏‡•á‡§Ç‡§°‡§∞‡•ç‡§∏ ‡§¶‡•á‡§ñ‡•á‡§Ç‡•§\n"
        "`/admins`: ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§∏‡§≠‡•Ä ‡§è‡§°‡§Æ‡§ø‡§® ‡§ï‡•ã ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§\n"
        "`/info <reply>`: ‡§ï‡§ø‡§∏‡•Ä ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§™‡§æ‡§è‡§Ç‡•§\n"
        "`/chatinfo`: ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§¨‡§æ‡§∞‡•á ‡§Æ‡•á‡§Ç ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§™‡§æ‡§è‡§Ç‡•§\n"
        "`/ping`: ‡§¨‡•â‡§ü ‡§ï‡•Ä ‡§ó‡§§‡§ø (speed) ‡§ï‡•ã ‡§ö‡•á‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§"
    )
    buttons = [[InlineKeyboardButton("üîô ‡§µ‡§æ‡§™‡§∏", callback_data="show_help")]]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_text(text, parse_mode=ParseMode.MARKDOWN, reply_markup=reply_markup)

@bot.on_callback_query(filters.regex("go_back"))
async def go_back_callback(_, callback_query):
    user_id = callback_query.from_user.id
    raw_name = callback_query.from_user.first_name or ""
    styled_name = to_bold_unicode(raw_name)

    caption = (
        f"üëã **‡§®‡§Æ‡§∏‡•ç‡§§‡•á {styled_name}!**\n\n"
        f"‡§Æ‡•à‡§Ç ‡§è‡§ï ‡§è‡§°‡§µ‡§æ‡§Ç‡§∏ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•à‡§®‡•á‡§ú‡§Æ‡•á‡§Ç‡§ü ‡§Ö‡§∏‡§ø‡§∏‡•ç‡§ü‡•á‡§Ç‡§ü ‡§π‡•Ç‡§Å‡•§\n"
        f"‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•ã ‡§∏‡§æ‡§´, ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§î‡§∞ ‡§µ‡•ç‡§Ø‡§µ‡§∏‡•ç‡§•‡§ø‡§§ ‡§∞‡§ñ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡§æ ‡§π‡•Ç‡§Å‡•§\n\n"
        f"‡§Æ‡•á‡§∞‡•á ‡§∏‡§≠‡•Ä ‡•û‡•Ä‡§ö‡§∞‡•ç‡§∏ ‡§ï‡•ã ‡§è‡§ï‡•ç‡§∏‡§™‡•ç‡§≤‡•ã‡§∞ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è, ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è **Help** ‡§¨‡§ü‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§\n\n"
        f"**Developer:** [Shubham](tg://user?id={OWNER_ID})"
    )
    buttons = [
        [
            InlineKeyboardButton("‚ûï ‡§Æ‡•Å‡§ù‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§ú‡•ã‡§°‡§º‡•á‡§Ç", url=f"https://t.me/{bot.get_me().username}?startgroup=true"),
            InlineKeyboardButton("üì¢ ‡§Ö‡§™‡§°‡•á‡§ü‡•ç‡§∏", url="https://t.me/vibeshiftbots")
        ],
        [
            InlineKeyboardButton("‚ùì Help", callback_data="show_help"),
            InlineKeyboardButton("üí¨ ‡§∏‡§™‡•ã‡§∞‡•ç‡§ü", url="https://t.me/Frozensupport1")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(buttons)
    await callback_query.message.edit_caption(
        caption=caption,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=reply_markup
    )

# --- Welcome/Onboarding Feature ---
@bot.on_message(filters.new_chat_members)
async def welcome_new_member(client, message):
    chat_id = message.chat.id
    for member in message.new_chat_members:
        if member.is_bot:
            continue
        
        if chat_id in custom_welcome_messages:
            welcome_text = custom_welcome_messages[chat_id]
        else:
            welcome_text = (
                f"üëã **{member.first_name}** ‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à! üéâ\n\n"
                "‡§ï‡•É‡§™‡§Ø‡§æ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§á‡§® ‡§®‡§ø‡§Ø‡§Æ‡•ã‡§Ç ‡§ï‡§æ ‡§™‡§æ‡§≤‡§® ‡§ï‡§∞‡•á‡§Ç:\n"
                "1. ‡§ï‡•ã‡§à ‡§∏‡•ç‡§™‡•à‡§Æ‡§ø‡§Ç‡§ó ‡§®‡§π‡•Ä‡§Ç\n"
                "2. ‡§ï‡•ã‡§à ‡§ó‡§æ‡§≤‡•Ä-‡§ó‡§≤‡•å‡§ú ‡§®‡§π‡•Ä‡§Ç\n"
                "3. ‡§ï‡•á‡§µ‡§≤ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§∏‡§Ç‡§¨‡§Ç‡§ß‡§ø‡§§ ‡§¨‡§æ‡§§‡•á‡§Ç ‡§ï‡§∞‡•á‡§Ç‡•§"
            )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úÖ ‡§Æ‡•à‡§Ç‡§®‡•á ‡§®‡§ø‡§Ø‡§Æ ‡§™‡§¢‡§º ‡§≤‡§ø‡§è ‡§π‡•à‡§Ç", callback_data="rules_accepted")]
        ])
        await client.send_message(chat_id, welcome_text, reply_markup=keyboard)

@bot.on_message(filters.group & filters.command("setwelcome"))
async def set_welcome_message(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§")
    
    parts = message.text.split(" ", 1)
    if len(parts) < 2:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§π ‡§Æ‡•à‡§∏‡•á‡§ú ‡§¶‡•á‡§Ç ‡§ú‡§ø‡§∏‡•á ‡§Ü‡§™ ‡§µ‡•á‡§≤‡§ï‡§Æ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§¨‡§®‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§")
    
    custom_welcome_messages[message.chat.id] = parts[1]
    await message.reply("‚úÖ ‡§ï‡§∏‡•ç‡§ü‡§Æ ‡§µ‡•á‡§≤‡§ï‡§Æ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§∏‡•á‡§ü ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")

@bot.on_message(filters.group & filters.command("setphotowelcome"))
async def set_photo_welcome(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§")
    
    if not message.reply_to_message or not message.reply_to_message.photo:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡•û‡•ã‡§ü‡•ã ‡§™‡§∞ ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç‡•§")

    caption = message.text.split(" ", 1)
    if len(caption) < 2:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡•û‡•ã‡§ü‡•ã ‡§ï‡•á ‡§∏‡§æ‡§• ‡§µ‡•á‡§≤‡§ï‡§Æ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§≠‡•Ä ‡§¶‡•á‡§Ç‡•§")

    custom_welcome_messages[message.chat.id] = {"photo": message.reply_to_message.photo.file_id, "caption": caption[1]}
    await message.reply("‚úÖ ‡•û‡•ã‡§ü‡•ã ‡§ï‡•á ‡§∏‡§æ‡§• ‡§µ‡•á‡§≤‡§ï‡§Æ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§∏‡•á‡§ü ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")

@bot.on_callback_query(filters.regex("rules_accepted"))
async def handle_rules_accepted(client, callback_query):
    user_id = callback_query.from_user.id
    message = callback_query.message
    
    if len(message.entities) > 1 and message.entities[1].type == "text_mention":
        joined_user_id = message.entities[1].user.id
        if joined_user_id != user_id:
            await callback_query.answer("‚ùå ‡§Ü‡§™ ‡§ï‡§ø‡§∏‡•Ä ‡§î‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Ø‡§π ‡§¨‡§ü‡§® ‡§®‡§π‡•Ä‡§Ç ‡§¶‡§¨‡§æ ‡§∏‡§ï‡§§‡•á‡•§", show_alert=True)
            return

    await callback_query.answer("‚úÖ ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ü‡§™ ‡§Ö‡§¨ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§≠‡§æ‡§ó ‡§≤‡•á ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§", show_alert=False)
    try:
        await callback_query.message.delete()
    except Exception as e:
        print(f"Error deleting welcome message: {e}")

# --- Moderation Commands ---
@bot.on_message(filters.group & filters.command("mute"))
async def mute_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
    
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.restrict_chat_member(
            chat_id=message.chat.id,
            user_id=target_user.id,
            permissions=ChatPermissions(can_send_messages=False)
        )
        await message.reply(f"üîá ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action("Mute", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("unmute"))
async def unmute_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.unban_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply(f"üîä ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§Ö‡§®‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action("Unmute", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§Ö‡§®‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("tmute"))
async def tmute_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
        
    parts = message.text.split()
    if len(parts) < 3:
        return await message.reply("‚ùå ‡§∏‡§π‡•Ä ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤: `/tmute <reply_to_user> <minutes>`")
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        mute_minutes = int(parts[2])
    except (IndexError, ValueError):
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡§Æ‡§Ø ‡§Æ‡§ø‡§®‡§ü‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ ‡§ï‡•á ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç ‡§¶‡•á‡§Ç‡•§")

    mute_end_date = datetime.now(timezone.utc) + timedelta(minutes=mute_minutes)
    try:
        await client.restrict_chat_member(
            chat_id=message.chat.id,
            user_id=target_user.id,
            permissions=ChatPermissions(can_send_messages=False),
            until_date=mute_end_date
        )
        await message.reply(f"‚è±Ô∏è ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã {mute_minutes} ‡§Æ‡§ø‡§®‡§ü ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action(f"Temporary Mute ({mute_minutes} mins)", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§Ö‡§∏‡•ç‡§•‡§æ‡§Ø‡•Ä ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("kick"))
async def kick_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.kick_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply("üö™ ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§ï‡§ø‡§ï ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action("Kick", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§ï‡§ø‡§ï ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("ban"))
async def ban_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.ban_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply("üö´ ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á ‡§¨‡•à‡§® ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action("Ban", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§¨‡•à‡§® ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("unban"))
async def unban_user(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§")
        
    target_user = await extract_target_user(message)
    if not target_user:
        return
    try:
        await client.unban_chat_member(chat_id=message.chat.id, user_id=target_user.id)
        await message.reply("‚úÖ ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§Ö‡§®‡§¨‡•à‡§® ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
        await log_admin_action("Unban", message.from_user.first_name, target_user.first_name)
    except Exception as e:
        await message.reply(f"‚ùå ‡§Ø‡•Ç‡•õ‡§∞ ‡§ï‡•ã ‡§Ö‡§®‡§¨‡•à‡§® ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("del"))
async def delete_message(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§")
    
    if not message.reply_to_message:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§â‡§∏ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§™‡§∞ ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç ‡§ú‡§ø‡§∏‡•á ‡§Ü‡§™ ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§")
    
    try:
        await client.delete_messages(message.chat.id, [message.reply_to_message.id, message.id])
    except Exception as e:
        await message.reply(f"‚ùå ‡§Æ‡•à‡§∏‡•á‡§ú ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

# --- Anti-Abuse & Security ---
@bot.on_message(filters.group & ~filters.me & ~filters.via_bot)
async def anti_abuse_filter(client, message):
    if message.from_user and message.from_user.id in gban_list:
        try:
            await client.ban_chat_member(message.chat.id, message.from_user.id)
            return
        except Exception:
            pass

    user_status = (await client.get_chat_member(message.chat.id, message.from_user.id)).status
    if user_status in [ChatMemberStatus.ADMINISTRATOR, ChatMemberStatus.OWNER]:
        return

    # Auto-mute for low message count
    user_id = message.from_user.id
    if user_id not in user_stats or user_stats[user_id].get('messages', 0) < LOW_MSG_MUTE_THRESHOLD:
        try:
            await client.restrict_chat_member(
                chat_id=message.chat.id,
                user_id=user_id,
                permissions=ChatPermissions(can_send_messages=False),
                until_date=datetime.now(timezone.utc) + timedelta(seconds=LOW_MSG_MUTE_TIME)
            )
            await message.reply(f"üîá **{message.from_user.first_name}** ‡§ï‡•ã ‡§ï‡•Å‡§õ ‡§¶‡•á‡§∞ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à, ‡§ï‡•ç‡§Ø‡•ã‡§Ç‡§ï‡§ø ‡§Ü‡§™‡§ï‡•á ‡§Æ‡•à‡§∏‡•á‡§ú ‡§¨‡§π‡•Å‡§§ ‡§ï‡§Æ ‡§π‡•à‡§Ç‡•§ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§≠‡§æ‡§ó ‡§≤‡•á‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§î‡§∞ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§≠‡•á‡§ú‡•á‡§Ç‡•§")
        except Exception:
            pass
        return

    # Link filter with whitelist
    if message.text and re.search(r'(https?://\S+|t\.me/\S+)', message.text):
        is_whitelisted = False
        for domain in link_whitelist:
            if domain in message.text:
                is_whitelisted = True
                break
        
        if not is_whitelisted:
            try:
                await message.delete()
                await client.send_message(message.chat.id, f"‚ùå **{message.from_user.first_name}**, ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§≤‡§ø‡§Ç‡§ï ‡§≠‡•á‡§ú‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§")
            except Exception:
                pass
    
    # File type restriction
    if message.document:
        file_name, file_extension = os.path.splitext(message.document.file_name.lower())
        if file_extension in restricted_file_types:
            try:
                await message.delete()
                await client.send_message(message.chat.id, f"‚ùå **{message.from_user.first_name}**, ‡§á‡§∏ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ ‡§ï‡•Ä ‡•û‡§æ‡§á‡§≤‡•á‡§Ç ‡§≠‡•á‡§ú‡§®‡•á ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡•§")
            except Exception:
                pass

    if message.forward_from or message.forward_from_chat:
        try:
            await message.delete()
        except Exception:
            pass

    profanity_list = ["fuck", "bitch", "cunt", "chutiya", "randi"]
    if any(word in (message.text or '').lower() for word in profanity_list):
        try:
            await message.delete()
            await client.send_message(message.chat.id, f"‚ùå **{message.from_user.first_name}**, ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§ê‡§∏‡•Ä ‡§≠‡§æ‡§∑‡§æ ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§® ‡§ï‡§∞‡•á‡§Ç‡•§")
        except Exception:
            pass

@bot.on_message(filters.group & filters.command("whitelist"))
async def add_whitelist_domain(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§")
    
    parts = message.text.split()
    if len(parts) < 2:
        return await message.reply("‚ùå ‡§∏‡§π‡•Ä ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤: `/whitelist <domain>`")
    
    domain = parts[1].replace('https://', '').replace('http://', '').strip('/')
    link_whitelist.add(domain)
    await message.reply(f"‚úÖ `{domain}` ‡§ï‡•ã ‡§≤‡§ø‡§Ç‡§ï ‡§ï‡•Ä ‡§Ö‡§®‡•Å‡§Æ‡§§‡§ø ‡§µ‡§æ‡§≤‡•Ä ‡§≤‡§ø‡§∏‡•ç‡§ü ‡§Æ‡•á‡§Ç ‡§ú‡•ã‡§°‡§º‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")

@bot.on_message(filters.group & filters.command("restrictfiletype"))
async def restrict_file_type(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§")
    
    parts = message.text.split()
    if len(parts) < 2:
        return await message.reply("‚ùå ‡§∏‡§π‡•Ä ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤: `/restrictfiletype <.ext>`")
        
    file_extension = parts[1].lower()
    if not file_extension.startswith('.'):
        file_extension = '.' + file_extension
        
    restricted_file_types.add(file_extension)
    await message.reply(f"‚úÖ `{file_extension}` ‡•û‡§æ‡§á‡§≤ ‡§ü‡§æ‡§á‡§™ ‡§ï‡•ã ‡§™‡•ç‡§∞‡§§‡§ø‡§¨‡§Ç‡§ß‡§ø‡§§ ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")

# --- Automations & Workflows ---
@bot.on_message(filters.group & filters.text & ~filters.via_bot & filters.regex(r'(?i)^(hi|hello|namaste|rules|help)$'))
async def automation_handler(client, message):
    if not message.text:
        return
    
    text = message.text.lower()
    
    if "hi" in text or "hello" in text or "namaste" in text:
        await message.reply(f"‡§®‡§Æ‡§∏‡•ç‡§§‡•á, **{message.from_user.first_name}**! üëã\n‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à‡•§")

    elif "rules" in text:
        await message.reply("‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§®‡§ø‡§Ø‡§Æ ‡§ú‡§æ‡§®‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è `/help` ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§")

    elif "help" in text:
        await message.reply("‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§¶‡§¶ ‡§ï‡•à‡§∏‡•á ‡§ï‡§∞ ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Å? `/help` ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ï‡§æ ‡§™‡•ç‡§∞‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç ‡§Ø‡§æ ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è ‡§¨‡§ü‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§",
                            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùì Help Menu", callback_data="show_help")]]))

# --- New Games and Fun ---
@bot.on_message(filters.group & filters.command("truth"))
async def truth_game(_, message):
    question = random.choice(TRUTH_QUESTIONS)
    await message.reply(f"üí° **Truth**: {question}")

@bot.on_message(filters.group & filters.command("dare"))
async def dare_game(_, message):
    challenge = random.choice(DARE_CHALLENGES)
    await message.reply(f"üî• **Dare**: {challenge}")

@bot.on_message(filters.group & filters.command("trivia"))
async def start_trivia(_, message):
    if message.chat.id in trivia_game:
        return await message.reply("‚ùå ‡§è‡§ï ‡§ï‡•ç‡§µ‡§ø‡§ú‡§º ‡§™‡§π‡§≤‡•á ‡§∏‡•á ‡§π‡•Ä ‡§ö‡§≤ ‡§∞‡§π‡•Ä ‡§π‡•à‡•§")
    
    question = random.choice(list(TRIVIA_QUESTIONS.keys()))
    trivia_game[message.chat.id] = {"question": question, "answer": TRIVIA_QUESTIONS[question]}
    
    await message.reply(f"üß† **Trivia**: {question}\n\n‡§Ü‡§™‡§ï‡§æ ‡§â‡§§‡•ç‡§§‡§∞ ‡§á‡§∏ ‡§™‡§∞ ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡§ï‡•á ‡§¶‡•á‡§Ç‡•§")

@bot.on_message(filters.group & filters.text & filters.reply & filters.regex(r'^(?i)\S+'))
async def check_trivia_answer(_, message):
    if not message.reply_to_message or message.chat.id not in trivia_game:
        return
    
    if message.reply_to_message.from_user.id != bot.me.id:
        return
        
    if "Trivia" not in message.reply_to_message.text:
        return
        
    if message.text.lower() == trivia_game[message.chat.id]["answer"].lower():
        await message.reply(f"üéâ **‡§∏‡§π‡•Ä ‡§ú‡§µ‡§æ‡§¨!** **{message.from_user.first_name}** ‡§®‡•á ‡§∏‡§π‡•Ä ‡§ú‡§µ‡§æ‡§¨ ‡§¶‡§ø‡§Ø‡§æ‡•§")
        del trivia_game[message.chat.id]
    else:
        await message.reply("‚ùå **‡§ó‡§≤‡§§ ‡§ú‡§µ‡§æ‡§¨‡•§** ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§")

@bot.on_message(filters.group & filters.command("poll"))
async def poll_command(_, message):
    args = message.text.split()[1:]
    if len(args) < 3:
        await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§∏‡§µ‡§æ‡§≤ ‡§î‡§∞ ‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ ‡§¶‡•ã ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™ ‡§¶‡•á‡§Ç‡•§\n‡§∏‡§π‡•Ä ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤: `/poll ‡§Ü‡§™‡§ï‡§æ ‡§∏‡§µ‡§æ‡§≤? ‡§ë‡§™‡•ç‡§∂‡§®1 ‡§ë‡§™‡•ç‡§∂‡§®2 ...`")
        return

    question = args[0]
    options = args[1:]
    
    try:
        await bot.send_poll(
            chat_id=message.chat.id,
            question=question,
            options=options,
            is_anonymous=False
        )
        await message.delete()
    except Exception as e:
        await message.reply(f"‚ùå ‡§™‡•ã‡§≤ ‡§¨‡§®‡§æ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("couple"))
async def couple_command(client, message):
    try:
        members = []
        async for member in client.get_chat_members(message.chat.id):
            if not member.user.is_bot:
                members.append(member.user)
        
        if len(members) < 2:
            await message.reply("‚ùå ‡§á‡§∏ ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡§Æ ‡§∏‡•á ‡§ï‡§Æ 2 ‡§∏‡§¶‡§∏‡•ç‡§Ø ‡§π‡•ã‡§®‡•á ‡§ö‡§æ‡§π‡§ø‡§è‡•§")
            return

        couple = random.sample(members, 2)
        
        caption = (
            f"‚ù§Ô∏è **Group Couple of the Day** ‚ù§Ô∏è\n\n"
            f"**{couple[0].first_name}** üíò **{couple[1].first_name}**"
        )
        
        await message.reply(caption)
    except Exception as e:
        await message.reply(f"‚ùå ‡§á‡§∏ ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ï‡•ã ‡§ö‡§≤‡§æ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("dice"))
async def dice_command(client, message):
    await client.send_dice(message.chat.id)

@bot.on_message(filters.group & filters.command("tts"))
async def tts_command(client, message):
    text = " ".join(message.command[1:])
    if not text:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§ï‡•ã‡§à ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§¶‡•á‡§Ç‡•§\n‡§∏‡§π‡•Ä ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤: `/tts ‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Ü‡§™ ‡§ï‡•à‡§∏‡•á ‡§π‡•à‡§Ç?`")
    
    try:
        tts = gTTS(text=text, lang='hi', slow=False)
        tts.save("tts.mp3")
        await client.send_audio(chat_id=message.chat.id, audio="tts.mp3", caption=f"‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü-‡§ü‡•Ç-‡§∏‡•ç‡§™‡•Ä‡§ö ‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ ‡§≠‡•á‡§ú‡§æ ‡§ó‡§Ø‡§æ:\n`{text}`")
        os.remove("tts.mp3")
    except Exception as e:
        await message.reply(f"‚ùå ‡§ë‡§°‡§ø‡§Ø‡•ã ‡§¨‡§®‡§æ‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("vtt"))
async def voice_to_text_command(client, message):
    if not message.reply_to_message or not message.reply_to_message.voice:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§µ‡•â‡§á‡§∏ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§™‡§∞ ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç‡•§")

    try:
        await message.reply("üîÑ ‡§ü‡•ç‡§∞‡§æ‡§Ç‡§∏‡§ï‡•ç‡§∞‡§æ‡§á‡§¨ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ ‡§∞‡§π‡§æ ‡§π‡•à... ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ï‡§∞‡•á‡§Ç‡•§")
        voice_file_path = await message.reply_to_message.download()

        audio = AudioSegment.from_ogg(voice_file_path)
        audio.export("voice.wav", format="wav")

        recognizer = sr.Recognizer()
        with sr.AudioFile("voice.wav") as source:
            audio_data = recognizer.record(source)
            text = recognizer.recognize_google(audio_data, language="hi-IN")
            await message.reply(f"üé§ **‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü:** `{text}`")

    except sr.UnknownValueError:
        await message.reply("‚ùå ‡§µ‡•â‡§á‡§∏ ‡§ï‡•ã ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§∏‡§ï‡§æ‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§∏‡•ç‡§™‡§∑‡•ç‡§ü ‡§¨‡•ã‡§≤‡•á‡§Ç‡•§")
    except Exception as e:
        await message.reply(f"‚ùå ‡§µ‡•â‡§á‡§∏ ‡§ï‡•ã ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")
    finally:
        if os.path.exists(voice_file_path):
            os.remove(voice_file_path)
        if os.path.exists("voice.wav"):
            os.remove("voice.wav")

@bot.on_message(filters.group & filters.command("getfile"))
async def get_file_from_sticker(client, message):
    if not message.reply_to_message or not message.reply_to_message.sticker:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§∏‡•ç‡§ü‡§ø‡§ï‡§∞ ‡§™‡§∞ ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç‡•§")

    try:
        file_path = await message.reply_to_message.download()
        await message.reply_document(document=file_path)
        os.remove(file_path)
    except Exception as e:
        await message.reply(f"‚ùå ‡§∏‡•ç‡§ü‡§ø‡§ï‡§∞ ‡§ï‡•ã ‡•û‡§æ‡§á‡§≤ ‡§Æ‡•á‡§Ç ‡§¨‡§¶‡§≤‡§®‡•á ‡§Æ‡•á‡§Ç ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("gadminbroadcast") & filters.user(OWNER_ID))
async def group_admin_broadcast(client, message):
    broadcast_text = message.text.split(" ", 1)
    if len(broadcast_text) < 2:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§µ‡§π ‡§Æ‡•à‡§∏‡•á‡§ú ‡§¶‡•á‡§Ç ‡§ú‡§ø‡§∏‡•á ‡§Ü‡§™ ‡§¨‡•ç‡§∞‡•â‡§°‡§ï‡§æ‡§∏‡•ç‡§ü ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç‡•§")
    
    success_count = 0
    failure_count = 0
    
    async for dialog in client.get_dialogs():
        if dialog.chat.type in [ChatType.GROUP, ChatType.SUPERGROUP, ChatType.CHANNEL]:
            try:
                chat_member = await client.get_chat_member(dialog.chat.id, bot.me.id)
                if chat_member.status == ChatMemberStatus.ADMINISTRATOR:
                    await client.send_message(dialog.chat.id, broadcast_text[1])
                    success_count += 1
            except Exception:
                failure_count += 1
    
    await message.reply(f"‚úÖ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§≠‡•á‡§ú‡§æ ‡§ó‡§Ø‡§æ‡•§\n‡§∏‡§´‡§≤‡§§‡§æ: {success_count}\n‡§µ‡§ø‡§´‡§≤‡§§‡§æ: {failure_count}")

@bot.on_message(filters.group & filters.command("backup") & filters.user(OWNER_ID))
async def backup_data(_, message):
    save_data()
    await message.reply("‚úÖ ‡§°‡•á‡§ü‡§æ ‡§ï‡§æ ‡§¨‡•à‡§ï‡§Ö‡§™ ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§≤‡•á ‡§≤‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")

@bot.on_message(filters.group & filters.command("restore") & filters.user(OWNER_ID))
async def restore_data(_, message):
    load_data()
    await message.reply("‚úÖ ‡§°‡•á‡§ü‡§æ ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§∞‡•Ä‡§∏‡•ç‡§ü‡•ã‡§∞ ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")

@bot.on_message(filters.group & filters.command("settitle"))
async def set_group_title(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§")
    
    new_title = message.text.split(" ", 1)
    if len(new_title) < 2:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡§®‡§Ø‡§æ ‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï ‡§¶‡•á‡§Ç‡•§")

    try:
        await client.set_chat_title(message.chat.id, new_title[1])
        await message.reply("‚úÖ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡§æ ‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï ‡§¨‡§¶‡§≤ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§")
    except Exception as e:
        await message.reply(f"‚ùå ‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï ‡§¨‡§¶‡§≤‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

@bot.on_message(filters.group & filters.command("setphoto"))
async def set_group_photo(client, message):
    if not await is_admin_or_owner(message):
        return await message.reply("‚ùå ‡§Ü‡§™ ‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§á‡§∏‡•ç‡§§‡•á‡§Æ‡§æ‡§≤ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á‡•§")
    
    if not message.reply_to_message or not message.reply_to_message.photo:
        return await message.reply("‚ùå ‡§ï‡•É‡§™‡§Ø‡§æ ‡§è‡§ï ‡•û‡•ã‡§ü‡•ã ‡§™‡§∞ ‡§∞‡§ø‡§™‡•ç‡§≤‡§æ‡§à ‡§ï‡§∞‡•á‡§Ç‡•§")

    try:
        photo_path = await message.reply_to_message.download()
        await client.set_chat_photo(message.chat.id, photo=photo_path)
        await message.reply("‚úÖ ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•Ä ‡•û‡•ã‡§ü‡•ã ‡§¨‡§¶‡§≤ ‡§¶‡•Ä ‡§ó‡§à ‡§π‡•à‡•§")
        os.remove(photo_path)
    except Exception as e:
        await message.reply(f"‚ùå ‡•û‡•ã‡§ü‡•ã ‡§¨‡§¶‡§≤‡§®‡•á ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§à‡•§\nError: {e}")

# The bot will now start and load the data.
if __name__ == "__main__":
    load_data()
    print("Bot started. Press Ctrl+C to stop.")
    bot.run()
